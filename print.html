<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Little Book of Rust Macros</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="res/rust-syntax-bg-highlight.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "ayu";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Little Book of Rust Macros</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/veykril/tlborm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- This is a dummy file to include the README, this works around a bug in mdbook when including files outside the current dir in the summary -->
<h1 id="the-little-book-of-rust-macros"><a class="header" href="#the-little-book-of-rust-macros">The Little Book of Rust Macros</a></h1>
<blockquote>
<p><strong>Note</strong>: This is a continuation of <a href="https://github.com/DanielKeep/tlborm">Daniel Keep's Book</a> which has not been updated since the early summer of 2016, adapted to make use of <a href="https://github.com/rust-lang/mdBook">mdBook</a>.</p>
</blockquote>
<p>View the <a href="https://veykril.github.io/tlborm/">rendered version here</a> and the <a href="https://github.com/veykril/tlborm">repository here</a>.</p>
<p>A chinese version of this book can be found <a href="https://zjp-cn.github.io/tlborm/">here</a>.</p>
<p>This book is an attempt to distill the Rust community's collective knowledge of Rust macros, the <code>Macros by Example</code> ones as well as procedural macros(WIP).
As such, both additions (in the form of pull requests) and requests (in the form of issues) are very much welcome.
If something's unclear, opens up questions or is not understandable as written down, fear not to make an issue asking for clarification.
The goal is for this book to become the best learning resource possible.</p>
<p>The <a href="https://github.com/DanielKeep/tlborm">original Little Book of Rust Macros</a> has helped me immensely with understanding <em><strong>Macros by Example</strong></em> style macros while I was still learning the language.
Unfortunately, the original book hasn't been updated since April of 2016, while the Rust language as well as its macro-system keeps evolving.
Which is why I took up the task to update the book and keep it updated as well as I can while also adding newfound things to it.
In hopes that it will help out all the fresh faces coming to Rust understanding its macro systems, a part of the language a people tend to have trouble with.</p>
<blockquote>
<p>This book expects you to have basic knowledge of Rust, it will not explain language features or constructs that are irrelevant to macros.
No prior knowledge of macros is assumed.
Having read and understood the first seven chapters of the <a href="https://doc.rust-lang.org/stable/book/">Rust Book</a> is a must, though having read the majority of the book is recommended.</p>
</blockquote>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>A big thank you to Daniel Keep for the original work as well as all the contributors that added to the original which can be found <a href="https://github.com/DanielKeep/tlborm">here</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This work inherits the licenses of the original, hence it is licensed under both the <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a> and the <a href="http://opensource.org/licenses/MIT">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-extensions"><a class="header" href="#syntax-extensions">Syntax Extensions</a></h1>
<p>Before talking about Rust's different macro systems it is worthwhile to discuss the general mechanism they are built on: <em>syntax extensions</em>.</p>
<p>To do that, we must first discuss how Rust source is processed by the compiler, and the general mechanisms on which user-defined macros and proc-macros are built upon.</p>
<blockquote>
<p><strong>Note</strong>: This book will use the term <em>syntax extension</em> from now on when talking about all of rust's different macro kinds in general to reduce potential confusion with the upcoming <a href="https://github.com/rust-lang/rust/issues/39412">declarative macro 2.0</a> proposal which uses the <code>macro</code> keyword.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-analysis"><a class="header" href="#source-analysis">Source Analysis</a></h1>
<h3 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h3>
<p>The first stage of compilation for a Rust program is <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization">tokenization</a>. This is where the source text is
transformed into a sequence of tokens (<em>i.e.</em> indivisible lexical units; the programming language
equivalent of "words"). Rust has various kinds of tokens, such as:</p>
<ul>
<li>Identifiers: <code>foo</code>, <code>Bambous</code>, <code>self</code>, <code>we_can_dance</code>, <code>LaCaravane</code>, â€¦</li>
<li>Literals: <code>42</code>, <code>72u32</code>, <code>0_______0</code>, <code>1.0e-40</code>, <code>"ferris was here"</code>, â€¦</li>
<li>Keywords: <code>_</code>, <code>fn</code>, <code>self</code>, <code>match</code>, <code>yield</code>, <code>macro</code>, â€¦</li>
<li>Symbols: <code>[</code>, <code>:</code>, <code>::</code>, <code>?</code>, <code>~</code>, <code>@</code><sup class="footnote-reference" id="fr-wither-at-1"><a href="#footnote-wither-at">1</a></sup>, â€¦</li>
</ul>
<p>â€¦among others. There are some things to note about the above: first, <code>self</code> is both an identifier
<em>and</em> a keyword. In almost all cases, <code>self</code> is a keyword, but it <em>is</em> possible for it to be
<em>treated</em> as an identifier, which will come up later (along with much cursing). Secondly, the list
of keywords includes some suspicious entries such as <code>yield</code> and <code>macro</code> that aren't <em>actually</em> in
the language, but <em>are</em> parsed by the compilerâ€”these are <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved</a> for future use. Third, the list
of symbols <em>also</em> includes entries that aren't used by the language. In the case of <code>&lt;-</code>, it is
vestigial: it was removed from the grammar, but not from the lexer. As a final point, note that
<code>::</code> is a distinct token; it is not simply two adjacent <code>:</code> tokens. The same is true of all
multi-character symbol tokens in Rust, as of Rust 1.2.<sup class="footnote-reference" id="fr-two-lexers-1"><a href="#footnote-two-lexers">2</a></sup></p>
<p>As a point of comparison, it is at <em>this</em> stage that some languages have their macro layer, though
Rust does <em>not</em>. For example, C/C++ macros are <em>effectively</em> processed at this point.
<sup class="footnote-reference" id="fr-lies-damn-lies-cpp-1"><a href="#footnote-lies-damn-lies-cpp">3</a></sup> This is why the following code works:
<sup class="footnote-reference" id="fr-cpp-it-seemed-like-a-good-idea-at-the-time-1"><a href="#footnote-cpp-it-seemed-like-a-good-idea-at-the-time">4</a></sup></p>
<pre><code class="language-c">#define SUB int
#define BEGIN {
#define END }

SUB main() BEGIN
    printf("Oh, the horror!\n");
END
</code></pre>
<h3 id="parsing"><a class="header" href="#parsing">Parsing</a></h3>
<p>The next stage is parsing, where the stream of tokens is turned into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST).
This involves building up the syntactic structure of the program in memory. For example, the token
sequence <code>1 + 2</code> is transformed into the equivalent of:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BinOp   â”‚ â”Œâ•´â”‚ LitInt  â”‚
â”‚ op: Add â”‚ â”‚ â”‚ val: 1  â”‚
â”‚ lhs: â—Œ  â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt  â”‚
              â”‚ val: 2  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>The AST contains the structure of the <em>entire</em> program, though it is based on purely <em>lexical</em>
information. For example, although the compiler may know that a particular expression is referring
to a variable called <code>a</code>, at this stage, it has <em>no way</em> of knowing what <code>a</code> is, or even <em>where</em> it
comes from.</p>
<p>It is <em>after</em> the AST has been constructed that macros are processed. However, before we can discuss
that, we have to talk about token trees.</p>
<h2 id="token-trees"><a class="header" href="#token-trees">Token trees</a></h2>
<p>Token trees are somewhere between tokens and the AST. Firstly, <em>almost</em> all tokens are also token
trees; more specifically, they are <em>leaves</em>. There is one other kind of thing that can be a token
tree leaf, but we will come back to that later.</p>
<p>The only basic tokens that are <em>not</em> leaves are the "grouping" tokens: <code>(...)</code>, <code>[...]</code>, and <code>{...}</code>.
These three are the <em>interior nodes</em> of token trees, and what give them their structure. To give a
concrete example, this sequence of tokens:</p>
<pre><code class="language-text">a + b + (c + d[0]) + e
</code></pre>
<p>would be parsed into the following token trees:</p>
<pre><code class="language-text">Â«aÂ» Â«+Â» Â«bÂ» Â«+Â» Â«(   )Â» Â«+Â» Â«eÂ»
          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           Â«cÂ» Â«+Â» Â«dÂ» Â«[   ]Â»
                        â•­â”€â”´â”€â•®
                         Â«0Â»
</code></pre>
<p>Note that this has <em>no relationship</em> to the AST the expression would produce; instead of a single
root node, there are <em>seven</em> token trees at the root level. For reference, the AST would be:</p>
<pre><code class="language-text">                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                          â”‚ BinOp   â”‚
                                          â”‚ op: Add â”‚
                                        â”Œâ•´â”‚ lhs: â—Œ  â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ BinOp   â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Var     â”‚
                            â”‚ op: Add â”‚                 â”‚ name: e â”‚
                          â”Œâ•´â”‚ lhs: â—Œ  â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Var     â”‚â•¶â” â”‚ BinOp   â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
â”‚ name: a â”‚ â”‚ â”‚ op: Add â”‚                 â”‚ op: Add â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ lhs: â—Œ  â”‚               â”Œâ•´â”‚ lhs: â—Œ  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ•´â”‚ rhs: â—Œ  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Index   â”‚
â”‚ name: b â”‚                 â”‚ name: c â”‚               â”Œâ•´â”‚ arr: â—Œ  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ ind: â—Œ  â”‚â•¶â”
                                          â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                          â”‚ name: d â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ LitInt  â”‚â•¶â”˜
                                                        â”‚ val: 0  â”‚
                                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>It is important to understand the distinction between the AST and token trees. When writing macros,
you have to deal with <em>both</em> as distinct things.</p>
<p>One other aspect of this to note: it is <em>impossible</em> to have an unpaired parenthesis, bracket or brace;
nor is it possible to have incorrectly nested groups in a token tree.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-wither-at">
<p><code>@</code> has a purpose, though most people seem to forget about it completely: it is used
in patterns to bind a non-terminal part of the pattern to a name. <a href="#fr-wither-at-1">â†©</a></p>
</li>
<li id="footnote-two-lexers">
<p>Technically rust currently(1.46) has two lexers, <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_lexer"><code>rustc_lexer</code></a> which only emits
single character symbols as tokens and the <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/lexer">lexer</a> in <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse"><code>rustc_parse</code></a> which sees multi-character
symbols as distinct tokens. <a href="#fr-two-lexers-1">â†©</a></p>
</li>
<li id="footnote-lies-damn-lies-cpp">
<p>In fact, the C preprocessor uses a different lexical structure to C itself,
but the distinction is <em>broadly</em> irrelevant. <a href="#fr-lies-damn-lies-cpp-1">â†©</a></p>
</li>
<li id="footnote-cpp-it-seemed-like-a-good-idea-at-the-time">
<p><em>Whether</em> it should work is an entirely <em>different</em>
question. <a href="#fr-cpp-it-seemed-like-a-good-idea-at-the-time-1">â†©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="macros-in-the-ast"><a class="header" href="#macros-in-the-ast">Macros in the AST</a></h1>
<p>As previously mentioned, macro processing in Rust happens <em>after</em> the construction of the AST.
As such, the syntax used to invoke a macro <em>must</em> be a proper part of the language's syntax.
In fact, there are several "syntax extension" forms which are part of Rust's syntax.
Specifically, the following 4 forms (by way of examples):</p>
<ol>
<li><code># [ $arg ]</code>; <em>e.g.</em> <code>#[derive(Clone)]</code>, <code>#[no_mangle]</code>, â€¦</li>
<li><code># ! [ $arg ]</code>; <em>e.g.</em> <code>#![allow(dead_code)]</code>, <code>#![crate_name="blang"]</code>, â€¦</li>
<li><code>$name ! $arg</code>; <em>e.g.</em> <code>println!("Hi!")</code>, <code>concat!("a", "b")</code>, â€¦</li>
<li><code>$name ! $arg0 $arg1</code>; <em>e.g.</em> <code>macro_rules! dummy { () =&gt; {}; }</code>.</li>
</ol>
<p>The first two are <a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a> which annotate items, expressions and statements. They can be
classified into different kinds, <a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index">built-in attributes</a>, <a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">proc-macro attributes</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive attributes</a>.
<a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">proc-macro attributes</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive attributes</a> can be implemented with the second macro system that Rust
offers, <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>. <a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index">built-in attributes</a> on the other hand are attributes implemented by
the compiler.</p>
<p>The third form <code>$name ! $arg</code> are function-like macros. It is the form available for use with <code>macro_rules!</code>, <code>macro</code> and also procedural macros.
Note that this form is not <em>limited</em> to <code>macro_rules!</code> macros: it is a generic syntax extension form.
For example, whilst <a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a> is a <code>macro_rules!</code> macro, <a href="https://doc.rust-lang.org/std/macro.format_args.html"><code>format_args!</code></a> (which is used to <em>implement</em> <a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a>) is <em>not</em> as it is a compiler builtin.</p>
<p>The fourth form is essentially a variation which is <em>not</em> available to macros.
In fact, the only case where this form is used <em>at all</em> is with the <code>macro_rules!</code> construct itself.</p>
<p>So, starting with the third form, how does the Rust parser know what the <code>$arg</code> in (<code>$name ! $arg</code>) looks like for every possible syntax extension?
The answer is that it doesn't <em>have to</em>.
Instead, the argument of a syntax extension invocation is a <em>single</em> token tree.
More specifically, it is a single, <em>non-leaf</em> token tree; <code>(...)</code>, <code>[...]</code>, or <code>{...}</code>. With that
knowledge, it should become apparent how the parser can understand all of the following invocation
forms:</p>
<pre><code class="language-rust ignore">bitflags! {
    struct Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -&gt; u32 {
            match a {
                0 =&gt; 0,
                1 =&gt; 1,
                a =&gt; fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    use Color::*;
    let colors = vec![RED, GREEN, BLUE];
    println!("Hello, World!");
}</code></pre>
<p>Although the above invocations may <em>look</em> like they contain various kinds of Rust code, the parser simply sees a collection of meaningless token trees.
To make this clearer, we can replace all these syntactic "black boxes" with â¬š, leaving us with:</p>
<pre><code class="language-text">bitflags! â¬š

lazy_static! â¬š

fn main() {
    let colors = vec! â¬š;
    println! â¬š;
}
</code></pre>
<p>Just to reiterate: the parser does not assume <em>anything</em> about â¬š;
it remembers the tokens it contains, but doesn't try to <em>understand</em> them.
This means â¬š can be anything, even invalid Rust!
As to why this is a good thing, we will come back to that at a later point.</p>
<p>So, does this also apply to <code>$arg</code> in form 1 and 2, and to the two args in form 4? Kind of.
The <code>$arg</code> for form 1 and 2 is a bit different in that it is not directly a token tree, but a <em>simple path</em> that is either followed by an <code>=</code> token and a literal expression, or a token tree.
We will explore this more in-depth in the appropriate proc-macro chapter.
The important part here is that this form as well, makes use of token trees to describe the input.
The 4th form in general is more special and accepts a very specific grammar that also makes use of token trees though.
The specifics of this form do not matter at this point so we will skip them until they become relevant.</p>
<p>The important takeaways from this are:</p>
<ul>
<li>There are multiple kinds of syntax extensions in Rust.</li>
<li>Just seeing something of the form <code>$name! $arg</code>, doesn't tell you what kind of syntax extension it might be.
It could be a <code>macro_rules!</code> macro, a <code>proc-macro</code> or maybe even a builtin.</li>
<li>The input to every <code>!</code> macro invocation, that is form 3, is a single non-leaf token tree.</li>
<li>Syntax extensions are parsed as <em>part</em> of the abstract syntax tree.</li>
</ul>
<p>The last point is the most important, as it has <em>significant</em> implications.
Because syntax extensions are parsed into the AST, they can <strong>only</strong> appear in positions where they are explicitly supported.
Specifically syntax extensions can appear in place of the following:</p>
<ul>
<li>Patterns</li>
<li>Statements</li>
<li>Expressions</li>
<li>Items(this includes <code>impl</code> items)</li>
<li>Types</li>
</ul>
<p>Some things <em>not</em> on this list:</p>
<ul>
<li>Identifiers</li>
<li>Match arms</li>
<li>Struct fields</li>
</ul>
<p>There is absolutely, definitely <em>no way</em> to use syntax extensions in any position <em>not</em> on the first list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expansion"><a class="header" href="#expansion">Expansion</a></h1>
<p>Expansion is a relatively simple affair.
At some point <em>after</em> the construction of the AST, but before the compiler begins constructing its semantic understanding of the program, it will expand all syntax extensions.</p>
<p>This involves traversing the AST, locating syntax extension invocations and replacing them with their expansion.</p>
<p>Once the compiler has run a syntax extension, it expects the result to be parsable as one of a limited set of syntax elements, based on context.
For example, if you invoke a syntax extension at module scope, the compiler will parse the result into an AST node that represents an item.
If you invoke a syntax extension in expression position, the compiler will parse the result into an expression AST node.</p>
<p>In fact, it can turn a syntax extension result into any of the following:</p>
<ul>
<li>an expression,</li>
<li>a pattern,</li>
<li>a type,</li>
<li>zero or more items, or</li>
<li>zero or more statements.</li>
</ul>
<p>In other words, <em>where</em> you can invoke a syntax extension determines what its result will be interpreted as.</p>
<p>The compiler will take this AST node and completely replace the syntax extension's invocation node with the output node.
<em>This is a structural operation</em>, not a textual one!</p>
<p>For example, consider the following:</p>
<pre><code class="language-rust ignore">let eight = 2 * four!();</code></pre>
<p>We can visualize this partial AST as follows:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Let         â”‚
â”‚ name: eight â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ init: â—Œ     â”‚â•¶â”€â•´â”‚ BinOp   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ op: Mul â”‚
                â”Œâ•´â”‚ lhs: â—Œ  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Macro      â”‚
     â”‚ val: 2 â”‚                 â”‚ name: four â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ body: ()   â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>From context, <code>four!()</code> <em>must</em> expand to an expression (the initializer can <em>only</em> be an expression).
Thus, whatever the actual expansion is, it will be interpreted as a complete expression.
In this case, we will assume <code>four!</code> is defined such that it expands to the expression <code>1 + 3</code>.
As a result, expanding this invocation will result in the AST changing to:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Let         â”‚
â”‚ name: eight â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ init: â—Œ     â”‚â•¶â”€â•´â”‚ BinOp   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ op: Mul â”‚
                â”Œâ•´â”‚ lhs: â—Œ  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
     â”‚ val: 2 â”‚                 â”‚ op: Add â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt â”‚
                   â”‚ val: 1 â”‚                 â”‚ val: 3 â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>This can be written out like so:</p>
<pre><code class="language-rust ignore">let eight = 2 * (1 + 3);</code></pre>
<p>Note that we added parentheses <em>despite</em> them not being in the expansion.
Remember that the compiler always treats the expansion of a syntax extension as a complete AST node, <strong>not</strong> as a mere sequence of tokens.
To put it another way, even if you don't explicitly wrap a complex expression in parentheses, there is no way for the compiler to "misinterpret" the result, or change the order of evaluation.</p>
<p>It is important to understand that syntax extension expansions are treated as AST nodes, as this design has two further implications:</p>
<ul>
<li>In addition to there being a limited number of invocation <em>positions</em>, syntax extension can <em>only</em> expand to the kind of AST node the parser <em>expects</em> at that position.</li>
<li>As a consequence of the above, syntax extension  <em>absolutely cannot</em> expand to incomplete or syntactically invalid constructs.</li>
</ul>
<p>There is one further thing to note about expansion: what happens when a syntax extension expands to something that contains <em>another</em> syntax extension invocation.
For example, consider an alternative definition of <code>four!</code>; what happens if it expands to <code>1 + three!()</code>?</p>
<pre><code class="language-rust ignore">let x = four!();</code></pre>
<p>Expands to:</p>
<pre><code class="language-rust ignore">let x = 1 + three!();</code></pre>
<p>This is resolved by the compiler checking the result of expansions for additional syntax extension invocations, and expanding them.
Thus, a second expansion step turns the above into:</p>
<pre><code class="language-rust ignore">let x = 1 + 3;</code></pre>
<p>The takeaway here is that expansion happens in "passes";
as many as is needed to completely expand all invocations.</p>
<p>Well, not <em>quite</em>.
In fact, the compiler imposes an upper limit on the number of such recursive passes it is willing to run before giving up.
This is known as the syntax extension recursion limit and defaults to 128.
If the 128th expansion contains a syntax extension invocation, the compiler will abort with an error indicating that the recursion limit was exceeded.</p>
<p>This limit can be raised using the <code>#![recursion_limit="â€¦"]</code> <a href="https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute">attribute</a>, though it <em>must</em> be done crate-wide.
Generally, it is recommended to try and keep syntax extension below this limit wherever possible as it may impact compilation times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h1>
<p>Hygiene is an important concept for macros.
It describes the ability for a macro to work in its own syntax context, not affecting nor being affected by its surroundings.
In other words this means that a syntax extension should be invocable anywhere without interfering with its surrounding context.</p>
<p>In a perfect world all syntax extensions in Rust would be fully hygienic, unfortunately this isn't the case, so care should be taken to avoid writing syntax extensions that aren't fully hygienic.
We will go into general hygiene concepts here which will be touched upon in the corresponding hygiene chapters for the different syntax extensions Rust has to offer.</p>
<p>Â </p>
<p>Hygiene mainly affects identifiers and paths emitted by syntax extensions.
In short, if an identifier created by a syntax extension cannot be accessed by the environment where the syntax extension has been invoked it is hygienic in regards to that identifier.
Likewise, if an identifier used in a syntax extension cannot reference something defined outside of a syntax extension it is considered hygienic.</p>
<blockquote>
<p><strong>Note</strong>: The terms <code>create</code> and <code>use</code> refer to the position the identifier is in.
That is the <code>Foo</code> in <code>struct Foo {}</code> or the <code>foo</code> in <code>let foo = â€¦;</code> are created in the sense that they introduce something new under the name,
but the <code>Foo</code> in <code>fn foo(_: Foo) {}</code> or the <code>foo</code> in <code>foo + 3</code> are usages in the sense that they are referring to something existing.</p>
</blockquote>
<p>This is best shown by example.</p>
<p>Let's assume we have some syntax extension <code>make_local</code> that expands to <code>let local = 0;</code>, that is it <em>creates</em> the identifier <code>local</code>.
Then given the following snippet:</p>
<pre><code class="language-rust ignore">make_local!();
assert_eq!(local, 0);</code></pre>
<p>If the <code>local</code> in <code>assert_eq!(local, 0);</code> resolves to the local defined by the syntax extension, the syntax extension is not hygienic (at least in regards to local names/bindings).</p>
<p>Now let's assume we have some syntax extension <code>use_local</code> that expands to <code>local = 42;</code>, that is it makes <em>use</em> of the identifier <code>local</code>.
Then given the following snippet:</p>
<pre><code class="language-rust ignore">let mut local = 0;
use_local!();</code></pre>
<p>If the <code>local</code> inside of the syntax extension for the given invocation resolves to the local defined before its invocation, the syntax extension is not hygienic either.</p>
<p>This is a rather short introduction to the general concept of hygiene.
It will be explained in more depth in the corresponding <a href="syntax-extensions/../decl-macros/minutiae/hygiene.html"><code>macro_rules!</code> <code>hygiene</code></a> and <a href="syntax-extensions/../proc-macros/hygiene.html">proc-macro <code>hygiene</code></a> chapters, with their specific peculiarities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p><code>rustc</code> provides a number of tools to debug general syntax extensions, as well as some more specific ones tailored towards declarative and procedural macros respectively.</p>
<p>Sometimes, it is what the extension <em>expands to</em> that proves problematic as you do not usually see the expanded code.
Fortunately <code>rustc</code> offers the ability to look at the expanded code via the unstable <code>-Zunpretty=expanded</code> argument.
Given the following code:</p>
<pre><code class="language-rust ignore">// Shorthand for initializing a `String`.
macro_rules! S {
    ($e:expr) =&gt; {String::from($e)};
}

fn main() {
    let world = S!("World");
    println!("Hello, {}!", world);
}</code></pre>
<p>compiled with the following command:</p>
<pre><code class="language-shell">rustc +nightly -Zunpretty=expanded hello.rs
</code></pre>
<p>produces the following output (modified for formatting):</p>
<pre><code class="language-rust ignore">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
// Shorthand for initializing a `String`.
macro_rules! S { ($e : expr) =&gt; { String :: from($e) } ; }

fn main() {
    let world = String::from("World");
    {
        ::std::io::_print(
            ::core::fmt::Arguments::new_v1(
                &amp;["Hello, ", "!\n"],
                &amp;match (&amp;world,) {
                    (arg0,) =&gt; [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt)
                    ],
                }
            )
        );
    };
}</code></pre>
<p>But not just <code>rustc</code> exposes means to aid in debugging syntax extensions.
For the aforementioned <code>-Zunpretty=expanded</code> option, there exists a nice <code>cargo</code> plugin called <a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a> made by <a href="https://github.com/dtolnay"><code>dtolnay</code></a> which is basically just a wrapper around it.</p>
<p>You can also use the <a href="https://play.rust-lang.org/">playground</a>, clicking on its <code>TOOLS</code> button in the top right gives you the option to expand syntax extensions as well!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declarative-macros"><a class="header" href="#declarative-macros">Declarative Macros</a></h1>
<p>This chapter will introduce Rust's declarative macro system: <a href="https://doc.rust-lang.org/reference/macros-by-example.html"><code>macro_rules!</code></a>.</p>
<p>There are two different introductions in this chapter, a <a href="./decl-macros/macros-methodical.html">methodical</a> and a <a href="./decl-macros/macros-practical.html">practical</a>.</p>
<p>The former will attempt to give you a complete and thorough explanation of <em>how</em> the system works, while the latter one will cover more practical examples.
As such, the <a href="./decl-macros/macros-methodical.html">methodical introduction</a> is intended for people who just want the system as a whole explained, while the <a href="./decl-macros/macros-practical.html">practical introduction</a> guides one through the implementation of a single macro.</p>
<p>Following up the two introductions it offers some generally very useful <a href="./decl-macros/patterns.html">patterns</a> and <a href="./decl-macros/building-blocks.html">building blocks</a> for creating feature-rich macros.</p>
<p>Other resources about declarative macros include the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros chapter of the Rust Book</a> which is a more approachable, high-level explanation as well as the reference <a href="https://doc.rust-lang.org/reference/macros-by-example.html">chapter</a> which goes more into the precise details of things.</p>
<blockquote>
<p><strong>Note</strong>: This book will usually use the term <em>mbe</em>(<strong>M</strong>acro-<strong>B</strong>y-<strong>E</strong>xample), <em>mbe macro</em> or <code>macro_rules!</code> macro when talking about <code>macro_rules!</code> macros.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros-a-methodical-introduction"><a class="header" href="#macros-a-methodical-introduction">Macros, A Methodical Introduction</a></h1>
<p>This chapter will introduce Rust's declarative <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macro-By-Example</a> system by explaining the system as a whole.
It will do so by first going into the construct's syntax and its key parts and then following it up with more general information that one should at least be aware of.</p>
<h1 id="macro_rules"><a class="header" href="#macro_rules"><code>macro_rules!</code></a></h1>
<p>With all that in mind, we can introduce <code>macro_rules!</code> itself.
As noted previously, <code>macro_rules!</code> is <em>itself</em> a syntax extension, meaning it is <em>technically</em> not part of the Rust syntax.
It uses the following forms:</p>
<pre><code class="language-rust ignore">macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // â€¦
    $ruleN ;
}</code></pre>
<p>There must be <em>at least</em> one rule, and you can omit the semicolon after the last rule.
You can use brackets(<code>[]</code>), parentheses(<code>()</code>) or braces(<code>{}</code>).</p>
<p>Each <em>"rule"</em> looks like the following:</p>
<pre><code class="language-ignore">    ($matcher) =&gt; {$expansion}
</code></pre>
<p>Like before, the types of parentheses used can be any kind, but parentheses around the matcher and braces around the expansion are somewhat conventional.
The expansion part of a rule is also called its <em>transcriber</em>.</p>
<p>Note that the choice of the parentheses does not matter in regards to how the mbe macro may be invoked.
In fact, function-like macros can be invoked with any kind of parentheses as well, but invocations with <code>{ .. }</code> and <code>( ... );</code>, notice the trailing semicolon, are special in that their expansion will <em>always</em> be parsed as an <em>item</em>.</p>
<p>If you are wondering, the <code>macro_rules!</code> invocation expands to... <em>nothing</em>.
At least, nothing that appears in the AST; rather, it manipulates compiler-internal structures to register the mbe macro.
As such, you can <em>technically</em> use <code>macro_rules!</code> in any position where an empty expansion is valid.</p>
<h2 id="matching"><a class="header" href="#matching">Matching</a></h2>
<p>When a <code>macro_rules!</code> macro is invoked, the <code>macro_rules!</code> interpreter goes through the rules one by one, in declaration order.
For each rule, it tries to match the contents of the input token tree against that rule's <code>matcher</code>.
A matcher must match the <em>entirety</em> of the input to be considered a match.</p>
<p>If the input matches the matcher, the invocation is replaced by the <code>expansion</code>; otherwise, the next rule is tried.
If all rules fail to match, the expansion fails with an error.</p>
<p>The simplest example is of an empty matcher:</p>
<pre><code class="language-rust ignore">macro_rules! four {
    () =&gt; { 1 + 3 };
}</code></pre>
<p>This matches if and only if the input is also empty (<em>i.e.</em> <code>four!()</code>, <code>four![]</code> or <code>four!{}</code>).</p>
<p>Note that the specific grouping tokens you use when you invoke the function-like macro <em>are not</em> matched, they are in fact not passed to the invocation at all.
That is, you can invoke the above macro as <code>four![]</code> and it will still match.
Only the <em>contents</em> of the input token tree are considered.</p>
<p>Matchers can also contain literal token trees, which must be matched exactly.
This is done by simply writing the token trees normally.
For example, to match the sequence <code>4 fn ['spang "whammo"] @_@</code>, you would write:</p>
<pre><code class="language-rust ignore">macro_rules! gibberish {
    (4 fn ['spang "whammo"] @_@) =&gt; {...};
}</code></pre>
<p>You can use any token tree that you can write.</p>
<h2 id="metavariables"><a class="header" href="#metavariables">Metavariables</a></h2>
<p>Matchers can also contain captures.
These allow input to be matched based on some general grammar category, with the result captured to a metavariable which can then be substituted into the output.</p>
<p>Captures are written as a dollar (<code>$</code>) followed by an identifier, a colon (<code>:</code>), and finally the kind of capture which is also called the fragment-specifier, which must be one of the following:</p>
<ul>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#block"><code>block</code></a>: a block (i.e. a block of statements and/or an expression, surrounded by braces)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#expr"><code>expr</code></a>: an expression</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#ident"><code>ident</code></a>: an identifier (this includes keywords)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#item"><code>item</code></a>: an item, like a function, struct, module, impl, etc.</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#lifetime"><code>lifetime</code></a>: a lifetime (e.g. <code>'foo</code>, <code>'static</code>, ...)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#literal"><code>literal</code></a>: a literal (e.g. <code>"Hello World!"</code>, <code>3.14</code>, <code>'ğŸ¦€'</code>, ...)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#meta"><code>meta</code></a>: a meta item; the things that go inside the <code>#[...]</code> and <code>#![...]</code> attributes</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#pat"><code>pat</code></a>: a pattern</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#path"><code>path</code></a>: a path (e.g. <code>foo</code>, <code>::std::mem::replace</code>, <code>transmute::&lt;_, int&gt;</code>, â€¦)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#stmt"><code>stmt</code></a>: a statement</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#tt"><code>tt</code></a>: a single token tree</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#ty"><code>ty</code></a>: a type</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#vis"><code>vis</code></a>: a possible empty visibility qualifier (e.g. <code>pub</code>, <code>pub(in crate)</code>, ...)</li>
</ul>
<p>For more in-depth description of the fragment specifiers, check out the <a href="decl-macros/./minutiae/fragment-specifiers.html">Fragment Specifiers</a> chapter.</p>
<p>For example, here is a <code>macro_rules!</code> macro which captures its input as an expression under the metavariable <code>$e</code>:</p>
<pre><code class="language-rust ignore">macro_rules! one_expression {
    ($e:expr) =&gt; {...};
}</code></pre>
<p>These metavariables leverage the Rust compiler's parser, ensuring that they are always "correct".
An <code>expr</code> metavariable will <em>always</em> capture a complete, valid expression for the version of Rust being compiled.</p>
<p>You can mix literal token trees and metavariables, within limits (explained in <a href="decl-macros/./minutiae/metavar-and-expansion.html">Metavariables and Expansion Redux</a>).</p>
<p>To refer to a metavariable you simply write <code>$name</code>, as the type of the variable is already specified in the matcher. For example:</p>
<pre><code class="language-rust ignore">macro_rules! times_five {
    ($e:expr) =&gt; { 5 * $e };
}</code></pre>
<p>Much like macro expansion, metavariables are substituted as complete AST nodes.
This means that no matter what sequence of tokens is captured by <code>$e</code>, it will be interpreted as a single, complete expression.</p>
<p>You can also have multiple metavariables in a single matcher:</p>
<pre><code class="language-rust ignore">macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) =&gt; { $a * ($b + $c) };
}</code></pre>
<p>And use them as often as you like in the expansion:</p>
<pre><code class="language-rust ignore">macro_rules! discard {
    ($e:expr) =&gt; {};
}
macro_rules! repeat {
    ($e:expr) =&gt; { $e; $e; $e; };
}</code></pre>
<p>There is also a special metavariable called <a href="decl-macros/./minutiae/hygiene.html#crate"><code>$crate</code></a> which can be used to refer to the current crate.</p>
<h2 id="repetitions"><a class="header" href="#repetitions">Repetitions</a></h2>
<p>Matchers can contain repetitions. These allow a sequence of tokens to be matched.
These have the general form <code>$ ( ... ) sep rep</code>.</p>
<ul>
<li>
<p><code>$</code> is a literal dollar token.</p>
</li>
<li>
<p><code>( ... )</code> is the paren-grouped matcher being repeated.</p>
</li>
<li>
<p><code>sep</code> is an <em>optional</em> separator token. It may not be a delimiter or one
of the repetition operators. Common examples are <code>,</code> and <code>;</code>.</p>
</li>
<li>
<p><code>rep</code> is the <em>required</em> repeat operator. Currently, this can be:</p>
<ul>
<li><code>?</code>: indicating at most one repetition</li>
<li><code>*</code>: indicating zero or more repetitions</li>
<li><code>+</code>: indicating one or more repetitions</li>
</ul>
<p>Since <code>?</code> represents at most one occurrence, it cannot be used with a separator.</p>
</li>
</ul>
<p>Repetitions can contain any other valid matcher, including literal token trees, metavariables, and other repetitions allowing arbitrary nesting.</p>
<p>Repetitions use the same syntax in the expansion and repeated metavariables can only be accessed inside of repetitions in the expansion.</p>
<p>For example, below is a mbe macro which formats each element as a string.
It matches zero or more comma-separated expressions and expands to an expression that constructs a vector.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! vec_strs {
    (
        // Start a repetition:
        $(
            // Each repeat must contain an expression...
            $element:expr
        )
        // ...separated by commas...
        ,
        // ...zero or more times.
        *
    ) =&gt; {
        // Enclose the expansion in a block so that we can use
        // multiple statements.
        {
            let mut v = Vec::new();

            // Start a repetition:
            $(
                // Each repeat will contain the following statement, with
                // $element replaced with the corresponding expression.
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}

fn main() {
    let s = vec_strs![1, "a", true, 3.14159f32];
    assert_eq!(s, &amp;["1", "a", "true", "3.14159"]);
}</code></pre></pre>
<p>You can repeat multiple metavariables in a single repetition as long as all metavariables repeat equally often.
So this invocation of the following macro works:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! repeat_two {
    ($($i:ident)*, $($i2:ident)*) =&gt; {
        $( let $i: (); let $i2: (); )*
    }
}

repeat_two!( a b c d e f, u v w x y z );
<span class="boring">}</span></code></pre></pre>
<p>But this does not:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! repeat_two {
</span><span class="boring">    ($($i:ident)*, $($i2:ident)*) =&gt; {
</span><span class="boring">        $( let $i: (); let $i2: (); )*
</span><span class="boring">    }
</span><span class="boring">}
</span>
repeat_two!( a b c d e f, x y z );
<span class="boring">}</span></code></pre></pre>
<p>failing with the following error</p>
<pre><code class="language-text">error: meta-variable `i` repeats 6 times, but `i2` repeats 3 times
 --&gt; src/main.rs:6:10
  |
6 |         $( let $i: (); let $i2: (); )*
  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h2 id="metavariable-expressions"><a class="header" href="#metavariable-expressions">Metavariable Expressions</a></h2>
<blockquote>
<p><em>RFC</em>: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md">rfcs#1584</a><br />
<em>Tracking Issue</em>: <a href="https://github.com/rust-lang/rust/issues/83527">rust#83527</a><br />
<em>Feature</em>: <code>#![feature(macro_metavar_expr)]</code></p>
</blockquote>
<p>Transcriber can contain what is called metavariable expressions.
Metavariable expressions provide transcribers with information about metavariables that are otherwise not easily obtainable.
With the exception of the <code>$$</code> expression, these have the general form <code>$ { op(...) }</code>.
Currently all metavariable expressions but <code>$$</code> deal with repetitions.</p>
<p>The following expressions are available with <code>ident</code> being the name of a bound metavariable and <code>depth</code> being an integer literal:</p>
<ul>
<li><code>${count(ident)}</code>: The number of times <code>$ident</code> repeats in the inner-most repetition in total. This is equivalent to <code>${count(ident, 0)}</code>.</li>
<li><code>${count(ident, depth)}</code>: The number of times <code>$ident</code> repeats in the repetition at <code>depth</code>.</li>
<li><code>${index()}</code>: The current repetition index of the inner-most repetition. This is equivalent to <code>${index(0)}</code>.</li>
<li><code>${index(depth)}</code>: The current index of the repetition at <code>depth</code>, counting outwards.</li>
<li><code>${len()}</code>: The number of times the inner-most repetition will repeat for. This is equivalent to <code>${len(0)}</code>.</li>
<li><code>${len(depth)}</code>: The number of times the repetition at <code>depth</code> will repeat for, counting outwards.</li>
<li><code>${ignore(ident)}</code>: Binds <code>$ident</code> for repetition, while expanding to nothing.</li>
<li><code>$$</code>:	Expands to a single <code>$</code>, effectively escaping the <code>$</code> token so it won't be transcribed.</li>
</ul>
<p>Â </p>
<p>For the complete grammar definition you may want to consult the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#macros-by-example">Macros By Example</a> chapter of the Rust reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros-a-practical-introduction"><a class="header" href="#macros-a-practical-introduction">Macros, A Practical Introduction</a></h1>
<p>This chapter will introduce Rust's declarative <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macro-By-Example</a> system using a relatively simple, practical example.
It does <em>not</em> attempt to explain all of the intricacies of the system; its goal is to get you comfortable with how and why macros are written.</p>
<p>There is also the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros chapter of the Rust Book</a> which is another high-level explanation, and the <a href="decl-macros/../decl-macros.html">methodical introduction</a> chapter of this book, which explains the macro system in detail.</p>
<h2 id="a-little-context"><a class="header" href="#a-little-context">A Little Context</a></h2>
<blockquote>
<p><strong>Note</strong>: don't panic! What follows is the only math that will be talked about.
You can quite safely skip this section if you just want to get to the meat of the article.</p>
</blockquote>
<p>If you aren't familiar, a recurrence relation is a sequence where each value is defined in terms of one or more <em>previous</em> values, with one or more initial values to get the whole thing started.
For example, the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a> can be defined by the relation:</p>
<p>\[F_{n} = 0, 1, ..., F_{n-2} + F_{n-1}\]</p>
<p>Thus, the first two numbers in the sequence are 0 and 1, with the third being \( F_{0} + F_{1} = 0 + 1 = 1\), the fourth \( F_{1} + F_{2} = 1 + 1 = 2\), and so on forever.</p>
<p>Now, <em>because</em> such a sequence can go on forever, that makes defining a <code>fibonacci</code> function a little tricky, since you obviously don't want to try returning a complete vector.
What you <em>want</em> is to return something which will lazily compute elements of the sequence as needed.</p>
<p>In Rust, that means producing an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>.
This is not especially <em>hard</em>, but there is a fair amount of boilerplate involved: you need to define a custom type, work out what state needs to be stored in it, then implement the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait for it.</p>
<p>However, recurrence relations are simple enough that almost all of these details can be abstracted out with a little <code>macro_rules!</code> macro-based code generation.</p>
<p>So, with all that having been said, let's get started.</p>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<p>Usually, when working on a new <code>macro_rules!</code> macro, the first thing I do is decide what the invocation should look like.
In this specific case, my first attempt looked like this:</p>
<pre><code class="language-rust ignore">let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]];

for e in fib.take(10) { println!("{}", e) }</code></pre>
<p>From that, we can take a stab at how the <code>macro_rules!</code> macro should be defined, even if we aren't sure of the actual expansion.
This is useful because if you can't figure out how to parse the input syntax, then <em>maybe</em> you need to change it.</p>
<pre><code class="language-rust ignore">macro_rules! recurrence {
    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}
<span class="boring">fn main() {}</span></code></pre>
<p>Assuming you aren't familiar with the syntax, allow me to elucidate.
This is defining a syntax extension, using the <a href="decl-macros/./macros-methodical.html"><code>macro_rules!</code></a> system, called <code>recurrence!</code>.
This <code>macro_rules!</code> macro has a single parsing rule.
That rule says the input to the invocation must match:</p>
<ul>
<li>the literal token sequence <code>a</code> <code>[</code> <code>n</code> <code>]</code> <code>=</code>,</li>
<li>a <a href="decl-macros/./macros-methodical.html#repetitions">repeating</a> (the <code>$( ... )</code>) sequence, using <code>,</code> as a separator, and one or more (<code>+</code>) repeats of:
<ul>
<li>a valid <em>expression</em> captured into the <a href="decl-macros/./macros-methodical.html#metavariables">metavariable</a> <code>inits</code> (<code>$inits:expr</code>)</li>
</ul>
</li>
<li>the literal token sequence <code>,</code> <code>...</code> <code>,</code>,</li>
<li>a valid <em>expression</em> captured into the <a href="decl-macros/./macros-methodical.html#metavariables">metavariable</a> <code>recur</code> (<code>$recur:expr</code>).</li>
</ul>
<p>Finally, the rule says that <em>if</em> the input matches this rule, then the invocation should be replaced by the token sequence <code>/* ... */</code>.</p>
<p>It's worth noting that <code>inits</code>, as implied by the name, actually contains <em>all</em> the expressions that match in this position, not just the first or last.
What's more, it captures them <em>as a sequence</em> as opposed to, say, irreversibly pasting them all together.
Also note that you can do "zero or more" with a repetition by using <code>*</code> instead of <code>+</code> and even optional, "zero or one" with <code>?</code>.</p>
<p>As an exercise, let's take the proposed input and feed it through the rule, to see how it is processed.
The "Position" column will show which part of the syntax pattern needs to be matched against next, denoted by a "âŒ‚".
Note that in some cases, there might be more than one possible "next" element to match against.
"Input" will contain all of the tokens that have <em>not</em> been consumed yet.
<code>inits</code> and <code>recur</code> will contain the contents of those bindings.</p>
<style type="text/css">
    /* Customisations. */

    .small-code code {
        font-size: 70%;
    }

    .parse-table {
        --table-width: 900px;
        width: var(--table-width);
        margin-left: calc((var(--content-max-width) - var(--table-width)) / 2);
    }

    table.parse-table code {
        white-space: pre-wrap;
        background-color: transparent;
        border: none;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code:nth-of-type(2) {
        color: red;
        margin-top: -0.7em;
        margin-bottom: -0.6em;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code {
        display: block;
    }

    table.parse-table tbody>tr>td:nth-child(2)>code {
        display: block;
    }
</style>
<table class="parse-table">
    <colgroup>
        <col width="42%" />
        <col width="30%" />
        <col width="0%" />
        <col width="18%" />
    </colgroup>
    <thead>
        <tr>
            <th>Position</th>
            <th>Input</th>
            <th><code>inits</code></th>
            <th><code>recur</code></th>
        </tr>
    </thead>
    <tbody class="small-code">
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>âŒ‚</code>
            </td>
            <td><code>a[n] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code> âŒ‚</code>
            </td>
            <td><code>[n] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>  âŒ‚</code>
            </td>
            <td><code>n] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>   âŒ‚</code>
            </td>
            <td><code>] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>     âŒ‚</code>
            </td>
            <td><code>= 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>       âŒ‚</code>
            </td>
            <td><code>0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         âŒ‚</code>
            </td>
            <td><code>0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     âŒ‚  âŒ‚</code>
            </td>
            <td><code>, 1, ..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: there are two âŒ‚ here, because the next input token might match <em>either</em> the comma
                separator <em>between</em> elements in the repetition, <em>or</em> the comma <em>after</em> the
                repetition. The macro system will keep track of both possibilities, until it is able to decide which one
                to follow.
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         âŒ‚                âŒ‚</code>
            </td>
            <td><code>1, ..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     âŒ‚  âŒ‚ <s>âŒ‚</s></code>
            </td>
            <td><code>, ..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: the third, crossed-out marker indicates that the macro system has, as a consequence of
                the last token consumed, eliminated one of the previous possible branches.
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         âŒ‚                âŒ‚</code>
            </td>
            <td><code>..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         <s>âŒ‚</s>                    âŒ‚</code>
            </td>
            <td><code>, a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                âŒ‚</code>
            </td>
            <td><code>a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                           âŒ‚</code>
            </td>
            <td></td>
            <td><code>0</code>, <code>1</code></td>
            <td><code>a[n-2] + a[n-1]</code></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: this particular step should make it clear that a binding like <tt>$recur:expr</tt> will
                consume an <em>entire expression</em>, using the compiler's knowledge of what constitutes a valid
                expression. As will be noted later, you can do this for other language constructs, too.
            </td>
        </tr>
    </tbody>
</table>
<p>The key take-away from this is that the macro system will <em>try</em> to incrementally match the tokens provided as input to the macro against the provided rules.
We'll come back to the "try" part.</p>
<p>Now, let's begin writing the final, fully expanded form.
For this expansion, I was looking for something like:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }</code></pre>
<p>This will be the actual iterator type.
<code>mem</code> will be the memo buffer to hold the last few values so the recurrence can be computed.
<code>pos</code> is to keep track of the value of <code>n</code>.</p>
<blockquote>
<p><strong>Aside</strong>: I've chosen <code>u64</code> as a "sufficiently large" type for the elements of this sequence.
Don't worry about how this will work out for <em>other</em> sequences; we'll come to it.</p>
</blockquote>
<pre><code class="language-rust ignore">    impl Iterator for Recurrence {
        type Item = u64;

        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)</code></pre>
<p>We need a branch to yield the initial values of the sequence; nothing tricky.</p>
<pre><code class="language-rust ignore">            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = a[n-2] + a[n-1];

                self.mem.TODO_shuffle_down_and_append(next_val);

                self.pos += 1;
                Some(next_val)
            }
        }
    }</code></pre>
<p>This is a bit harder; we'll come back and look at <em>how</em> exactly to define <code>a</code>.
Also, <code>TODO_shuffle_down_and_append</code> is another placeholder;
I want something that places <code>next_val</code> on the end of the array, shuffling the rest down by one space, dropping the 0th element.</p>
<pre><code class="language-rust ignore">
    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!("{}", e) }</code></pre>
<p>Lastly, return an instance of our new structure, which can then be iterated over.
To summarize, the complete expansion is:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }

    impl Iterator for Recurrence {
        type Item = u64;

        fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)
            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = (a[n-2] + a[n-1]);

                self.mem.TODO_shuffle_down_and_append(next_val.clone());

                self.pos += 1;
                Some(next_val)
            }
        }
    }

    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!("{}", e) }</code></pre>
<blockquote>
<p><strong>Aside</strong>: Yes, this <em>does</em> mean we're defining a different <code>Recurrence</code> struct and its implementation for each invocation.
Most of this will optimise away in the final binary.</p>
</blockquote>
<p>It's also useful to check your expansion as you're writing it.
If you see anything in the expansion that needs to vary with the invocation, but <em>isn't</em> in the actual accepted syntax of our macro, you should work out where to introduce it.
In this case, we've added <code>u64</code>, but that's not necessarily what the user wants, nor is it in the macro syntax. So let's fix that.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

/*
let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];

for e in fib.take(10) { println!("{}", e) }
*/
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Here, I've added a new metavariable: <code>sty</code> which should be a type.</p>
<blockquote>
<p><strong>Aside</strong>: if you're wondering, the bit after the colon in a metavariable can be one of several kinds of syntax matchers.
The most common ones are <code>item</code>, <code>expr</code>, and <code>ty</code>.
A complete explanation can be found in <a href="decl-macros/./macros-methodical.html#metavariables">Macros, A Methodical Introduction; <code>macro_rules!</code> (Matchers)</a>.</p>
<p>There's one other thing to be aware of: in the interests of future-proofing the language, the compiler restricts what tokens you're allowed to put <em>after</em> a matcher, depending on what kind it is.
Typically, this comes up when trying to match expressions or statements;
those can <em>only</em> be followed by one of <code>=&gt;</code>, <code>,</code>, and <code>;</code>.</p>
<p>A complete list can be found in <a href="decl-macros/./minutiae/metavar-and-expansion.html">Macros, A Methodical Introduction; Minutiae; Metavariables and Expansion Redux</a>.</p>
</blockquote>
<h2 id="indexing-and-shuffling"><a class="header" href="#indexing-and-shuffling">Indexing and Shuffling</a></h2>
<p>I will skim a bit over this part, since it's effectively tangential to the macro-related stuff.
We want to make it so that the user can access previous values in the sequence by indexing <code>a</code>;
we want it to act as a sliding window keeping the last few (in this case, 2) elements of the sequence.</p>
<p>We can do this pretty easily with a wrapper type:</p>
<pre><code class="language-rust ignore">struct IndexOffset&lt;'a&gt; {
    slice: &amp;'a [u64; 2],
    offset: usize,
}

impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
    type Output = u64;

    fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
        use std::num::Wrapping;

        let index = Wrapping(index);
        let offset = Wrapping(self.offset);
        let window = Wrapping(2);

        let real_index = index - offset + window;
        &amp;self.slice[real_index.0]
    }
}</code></pre>
<blockquote>
<p><strong>Aside</strong>: since lifetimes come up <em>a lot</em> with people new to Rust, a quick explanation: <code>'a</code> and <code>'b</code> are lifetime parameters that are used to track where a reference (<em>i.e.</em> a borrowed pointer to some data) is valid.
In this case, <code>IndexOffset</code> borrows a reference to our iterator's data, so it needs to keep track of how long it's allowed to hold that reference for, using <code>'a</code>.</p>
<p><code>'b</code> is used because the <code>Index::index</code> function (which is how subscript syntax is actually implemented) is <em>also</em> parameterized on a lifetime, on account of returning a borrowed reference.
<code>'a</code> and <code>'b</code> are not necessarily the same thing in all cases.
The borrow checker will make sure that even though we don't explicitly relate <code>'a</code> and <code>'b</code> to one another, we don't accidentally violate memory safety.</p>
</blockquote>
<p>This changes the definition of <code>a</code> to:</p>
<pre><code class="language-rust ignore">let a = IndexOffset { slice: &amp;self.mem, offset: n };</code></pre>
<p>The only remaining question is what to do about <code>TODO_shuffle_down_and_append</code>.
I wasn't able to find a method in the standard library with exactly the semantics I wanted, but it isn't hard to do by hand.</p>
<pre><code class="language-rust ignore">{
    use std::mem::swap;

    let mut swap_tmp = next_val;
    for i in (0..2).rev() {
        swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
    }
}</code></pre>
<p>This swaps the new value into the end of the array, swapping the other elements down one space.</p>
<blockquote>
<p><strong>Aside</strong>: doing it this way means that this code will work for non-copyable types, as well.</p>
</blockquote>
<p>The working code thus far now looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

fn main() {
    /*
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];

    for e in fib.take(10) { println!("{}", e) }
    */
    let fib = {
        use std::ops::Index;

        struct Recurrence {
            mem: [u64; 2],
            pos: usize,
        }

        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; 2],
            offset: usize,
        }

        impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;

            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;

                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(2);

                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }

        impl Iterator for Recurrence {
            type Item = u64;

            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; 2 {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset { slice: &amp;self.mem, offset: n };
                        a[n-2] + a[n-1]
                    };

                    {
                        use std::mem::swap;

                        let mut swap_tmp = next_val;
                        for i in [1,0] {
                            swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                        }
                    }

                    self.pos += 1;
                    Some(next_val)
                }
            }
        }

        Recurrence { mem: [0, 1], pos: 0 }
    };

    for e in fib.take(10) { println!("{}", e) }
}</code></pre></pre>
<p>Note that I've changed the order of the declarations of <code>n</code> and <code>a</code>, as well as wrapped them(along with the recurrence expression) in a block.
The reason for the first should be obvious(<code>n</code> needs to be defined first so I can use it for <code>a</code>).
The reason for the second is that the borrowed reference <code>&amp;self.mem</code> will prevent the swaps later on from happening (you cannot mutate something that is aliased elsewhere). The block ensures that the <code>&amp;self.mem</code> borrow expires before then.</p>
<p>Incidentally, the only reason the code that does the <code>mem</code> swaps is in a block is to narrow the scope in which <code>std::mem::swap</code> is available, for the sake of being tidy.</p>
<p>If we take this code and run it, we get:</p>
<pre><code class="language-text">0
1
1
2
3
5
8
13
21
34
</code></pre>
<p>Success!
Now, let's copy &amp; paste this into the macro expansion, and replace the expanded code with an invocation.
This gives us:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; {
        {
            /*
                What follows here is *literally* the code from before,
                cut and pasted into a new position. No other changes
                have been made.
            */

            use std::ops::Index;

            struct Recurrence {
                mem: [u64; 2],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [u64; 2],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = u64;

                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = u64;

                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; 2 {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-2] + a[n-1])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..2).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];

    for e in fib.take(10) { println!("{}", e) }
}</code></pre></pre>
<p>Obviously, we aren't <em>using</em> the metavariables yet, but we can change that fairly easily.
However, if we try to compile this, <code>rustc</code> aborts, telling us:</p>
<pre><code class="language-text">error: local ambiguity: multiple parsing options: built-in NTs expr ('inits') or 1 other option.
  --&gt; src/main.rs:75:45
   |
75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];
   |
</code></pre>
<p>Here, we've run into a limitation of the <code>macro_rules</code> system.
The problem is that second comma.
When it sees it during expansion, <code>macro_rules</code> can't decide if it's supposed to parse <em>another</em> expression for <code>inits</code>, or <code>...</code>.
Sadly, it isn't quite clever enough to realise that <code>...</code> isn't a valid expression, so it gives up.
Theoretically, this <em>should</em> work as desired, but currently doesn't.</p>
<blockquote>
<p><strong>Aside</strong>: I <em>did</em> fib a little about how our rule would be interpreted by the macro system.
In general, it <em>should</em> work as described, but doesn't in this case.
The <code>macro_rules</code> machinery, as it stands, has its foibles, and its worthwhile remembering that on occasion, you'll need to contort a little to get it to work.</p>
<p>In this <em>particular</em> case, there are two issues.
First, the macro system doesn't know what does and does not constitute the various grammar elements (<em>e.g.</em> an expression); that's the parser's job.
As such, it doesn't know that <code>...</code> isn't an expression.
Secondly, it has no way of trying to capture a compound grammar element (like an expression) without 100% committing to that capture.</p>
<p>In other words, it can ask the parser to try and parse some input as an expression, but the parser will respond to any problems by aborting.
The only way the macro system can currently deal with this is to just try to forbid situations where this could be a problem.</p>
<p>On the bright side, this is a state of affairs that exactly <em>no one</em> is enthusiastic about.
The <code>macro</code> keyword has already been reserved for a more rigorously-defined future <a href="https://github.com/rust-lang/rust/issues/39412">macro system</a>.
Until then, needs must.</p>
</blockquote>
<p>Thankfully, the fix is relatively simple: we remove the comma from the syntax.
To keep things balanced, we'll remove <em>both</em> commas around <code>...</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) =&gt; {
//                                     ^~~ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]];
//                                         ^~~ changed

    for e in fib.take(10) { println!("{}", e) }
}</code></pre></pre>
<p>Success! ... or so we thought.
Turns out this is being rejected by the compiler nowadays, while it was fine back when this was written.
The reason for this is that the compiler now recognizes the <code>...</code> as a token, and as we know we may only use <code>=&gt;</code>, <code>,</code> or <code>;</code> after an expression fragment.
So unfortunately we are now out of luck as our dreamed up syntax will not work out this way, so let us just choose one that looks the most befitting that we are allowed to use instead, I'd say replacing <code>,</code> with <code>;</code> works.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
//                                     ^~~~~~^ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];
//                                        ^~~~~^ changed

    for e in fib.take(10) { println!("{}", e) }
}</code></pre></pre>
<p>Success! But for real this time.</p>
<h3 id="substitution"><a class="header" href="#substitution">Substitution</a></h3>
<p>Substituting something you've captured in a macro is quite simple; you can insert the contents of a metavariable <code>$sty:ty</code> by using <code>$sty</code>.
So, let's go through and fix the <code>u64</code>s:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            struct Recurrence {
                mem: [$sty; 2],
//                    ^~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; 2],
//                          ^~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;
//                            ^~~~ changed

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
//                                                          ^~~~ changed
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;
//                          ^~~~ changed

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
//                                           ^~~~ changed
                    /* ... */
<span class="boring">                    if self.pos &lt; 2 {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let n = self.pos;
</span><span class="boring">                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
</span><span class="boring">                            (a[n-2] + a[n-1])
</span><span class="boring">                        };
</span><span class="boring">
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..2).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span>                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];

    for e in fib.take(10) { println!("{}", e) }
}</code></pre></pre>
<p>Let's tackle a harder one: how to turn <code>inits</code> into both the array literal <code>[0, 1]</code> <em>and</em> the array type, <code>[$sty; 2]</code>.
The first one we can do like so:</p>
<pre><code class="language-rust ignore">            Recurrence { mem: [$($inits),+], pos: 0 }
//                             ^~~~~~~~~~~ changed</code></pre>
<p>This effectively does the opposite of the capture: repeat <code>inits</code> one or more times, separating each with a comma.
This expands to the expected sequence of tokens: <code>0, 1</code>.</p>
<p>Somehow turning <code>inits</code> into a literal <code>2</code> is a little trickier.
It turns out that there's no direct way to do this, but we <em>can</em> do it by using a second <code>macro_rules!</code> macro.
Let's take this one step at a time.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    /* ??? */
<span class="boring">    () =&gt; {}
</span>}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The obvious case is: given zero expressions, you would expect <code>count_exprs</code> to expand to a literal
<code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
//  ^~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Aside</strong>: You may have noticed I used parentheses here instead of curly braces for the expansion.
<code>macro_rules</code> really doesn't care <em>what</em> you use, so long as it's one of the "matcher" pairs: <code>( )</code>, <code>{ }</code> or <code>[ ]</code>.
In fact, you can switch out the matchers on the macro itself(<em>i.e.</em> the matchers right after the macro name), the matchers around the syntax rule, and the matchers around the corresponding expansion.</p>
<p>You can also switch out the matchers used when you <em>invoke</em> a macro, but in a more limited fashion: a macro invoked as <code>{ ... }</code> or <code>( ... );</code> will <em>always</em> be parsed as an <em>item</em> (<em>i.e.</em> like a <code>struct</code> or <code>fn</code> declaration).
This is important when using macros in a function body; it helps disambiguate between "parse like an expression" and "parse like a statement".</p>
</blockquote>
<p>What if you have <em>one</em> expression?
That should be a literal <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
//  ^~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">}</span></code></pre></pre>
<p>Two?</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (2);
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}</span></code></pre></pre>
<p>We can "simplify" this a little by re-expressing the case of two expressions recursively.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
//                           ^~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}</span></code></pre></pre>
<p>This is fine since Rust can fold <code>1 + 1</code> into a constant value.
What if we have three expressions?</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
    ($e0:expr, $e1:expr, $e2:expr) =&gt; (1 + count_exprs!($e1, $e2));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Aside</strong>: You might be wondering if we could reverse the order of these rules.
In this particular case, <em>yes</em>, but the macro system can sometimes be picky about what it is and is not willing to recover from.
If you ever find yourself with a multi-rule macro that you <em>swear</em> should work, but gives you errors about unexpected tokens, try changing the order of the rules.</p>
</blockquote>
<p>Hopefully, you can see the pattern here.
We can always reduce the list of expressions by matching one expression, followed by zero or more expressions, expanding that into 1 + a count.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: this is not the <em>only</em>, or even the <em>best</em> way of counting things.
You may wish to peruse the <a href="decl-macros/./building-blocks/counting.html">Counting</a> section later for a more efficient way.</p>
</blockquote>
<p>With this, we can now modify <code>recurrence</code> to determine the necessary size of <code>mem</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">// added:
macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);
//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
//                          ^~~~~~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
//                                ^~~~~~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);
//                                        ^~~~~~~~ changed

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
//                                ^~~~~~~~ changed
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-2] + a[n-1])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
//                                       ^~~~~~~~ changed
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}
/* ... */
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];
</span><span class="boring">
</span><span class="boring">    for e in fib.take(10) { println!("{}", e) }
</span><span class="boring">}</span></code></pre></pre>
<p>With that done, we can now substitute the last thing: the <code>recur</code> expression.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr $(, $tail:expr)*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">              type Item = $sty;
</span>/* ... */
                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            $recur
//                          ^~~~~~ changed
                        };
                        {
                            use std::mem::swap;
                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }
                        self.pos += 1;
                        Some(next_val)
                    }
                }
/* ... */
<span class="boring">            }
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
</span><span class="boring">    for e in fib.take(10) { println!("{}", e) }
</span><span class="boring">}</span></code></pre></pre>
<p>And, when we compile our finished <code>macro_rules!</code> macro...</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:50
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                  ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:52
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                    ^ not found in this scope

error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:59
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                           ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:61
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                             ^ not found in this scope
</code></pre>
<p>... wait, what?
That can't be right... let's check what the macro is expanding to.</p>
<pre><code class="language-shell">$ rustc +nightly -Zunpretty=expanded recurrence.rs
</code></pre>
<p>The <code>-Zunpretty=expanded</code> argument tells <code>rustc</code> to perform macro expansion, then turn the resulting AST back into source code.
The output (after cleaning up some formatting) is shown below;
in particular, note the place in the code where <code>$recur</code> was substituted:</p>
<pre><code class="language-rust ignore">#![feature(no_std)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
fn main() {
    let fib = {
        use std::ops::Index;
        const MEM_SIZE: usize = 1 + 1;
        struct Recurrence {
            mem: [u64; MEM_SIZE],
            pos: usize,
        }
        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; MEM_SIZE],
            offset: usize,
        }
        impl &lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;
            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;
                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(MEM_SIZE);
                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }
        impl Iterator for Recurrence {
            type Item = u64;
            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; MEM_SIZE {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset{slice: &amp;self.mem, offset: n,};
                        a[n - 1] + a[n - 2]
                    };
                    {
                        use std::mem::swap;
                        let mut swap_tmp = next_val;
                        {
                            let result =
                                match ::std::iter::IntoIterator::into_iter((0..MEM_SIZE).rev()) {
                                    mut iter =&gt; loop {
                                        match ::std::iter::Iterator::next(&amp;mut iter) {
                                            ::std::option::Option::Some(i) =&gt; {
                                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                                            }
                                            ::std::option::Option::None =&gt; break,
                                        }
                                    },
                                };
                            result
                        }
                    }
                    self.pos += 1;
                    Some(next_val)
                }
            }
        }
        Recurrence{mem: [0, 1], pos: 0,}
    };
    {
        let result =
            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {
                mut iter =&gt; loop {
                    match ::std::iter::Iterator::next(&amp;mut iter) {
                        ::std::option::Option::Some(e) =&gt; {
                            ::std::io::_print(::std::fmt::Arguments::new_v1(
                                {
                                    static __STATIC_FMTSTR: &amp;'static [&amp;'static str] = &amp;["", "\n"];
                                    __STATIC_FMTSTR
                                },
                                &amp;match (&amp;e,) {
                                    (__arg0,) =&gt; [::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],
                                }
                            ))
                        }
                        ::std::option::Option::None =&gt; break,
                    }
                },
            };
        result
    }
}</code></pre>
<p>But that looks fine!
If we add a few missing <code>#![feature(...)]</code> attributes and feed it to a nightly build of <code>rustc</code>, it even compiles!  ... <em>what?!</em></p>
<blockquote>
<p><strong>Aside</strong>: You can't compile the above with a non-nightly build of <code>rustc</code>.
This is because the expansion of the <code>println!</code> macro depends on internal compiler details which are <em>not</em> publicly stabilized.</p>
</blockquote>
<h3 id="being-hygienic"><a class="header" href="#being-hygienic">Being Hygienic</a></h3>
<p>The issue here is that identifiers in Rust syntax extensions are <em>hygienic</em>.
That is, identifiers from two different contexts <em>cannot</em> collide.
To show the difference, let's take a simpler example.</p>
<pre><code class="language-rust ignore">macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42;
            $e
        }
    }
}

let four = using_a!(a / 10);
<span class="boring">fn main() {}</span></code></pre>
<p>This macro simply takes an expression, then wraps it in a block with a variable <code>a</code> defined.
We then use this as a round-about way of computing <code>4</code>.
There are actually <em>two</em> syntax contexts involved in this example, but they're invisible.
So, to help with this, let's give each context a different colour.
Let's start with the unexpanded code, where there is only a single context:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>Now, let's expand the invocation.</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>As you can see, the <code><span class="synctx-1">a</span></code> that's defined by the macro invocation is in a different context to the <code><span class="synctx-0">a</span></code> we provided in our invocation.
As such, the compiler treats them as completely different identifiers, <em>even though they have the same lexical appearance</em>.</p>
<p>This is something to be <em>really</em> careful of when working on <code>macro_rules!</code> macros, syntax extensions in general even: they can produce ASTs which
will not compile, but which <em>will</em> compile if written out by hand, or dumped using <code>-Zunpretty=expanded</code>.</p>
<p>The solution to this is to capture the identifier <em>with the appropriate syntax context</em>.
To do that, we need to again adjust our macro syntax.
To continue with our simpler example:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>This now expands to:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> </span><span class="synctx-0"><span class="ident">a</span></span><span class="synctx-1"> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>Now, the contexts match, and the code will compile.
We can make this adjustment to our <code>recurrence!</code> macro by explicitly capturing <code>a</code> and <code>n</code>.
After making the necessary changes, we have:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
//    ^~~~~~~~~~   ^~~~~~~~~~ changed
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let $ind = self.pos;
//                              ^~~~ changed
                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
//                              ^~~~ changed                                   ^~~~ changed
                            $recur
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];

    for e in fib.take(10) { println!("{}", e) }
}</code></pre></pre>
<p>And it compiles!
Now, let's try with a different sequence.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr) =&gt; (1);
</span><span class="boring">    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">                type Item = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline]
</span><span class="boring">                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
</span><span class="boring">                    if self.pos &lt; MEM_SIZE {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let $ind = self.pos;
</span><span class="boring">                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
</span><span class="boring">                            $recur
</span><span class="boring">                        };
</span><span class="boring">
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..MEM_SIZE).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {
    println!("{}", e)
}
<span class="boring">}</span></code></pre></pre>
<p>Which gives us:</p>
<pre><code class="language-text">1
1
2
6
24
120
720
5040
40320
362880
</code></pre>
<p>Success!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minutiae"><a class="header" href="#minutiae">Minutiae</a></h1>
<p>This section goes through some of the finer details of the <code>macro_rules!</code> system.
At a minimum, you should try to be at least <em>aware</em> of these details and issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fragment-specifiers"><a class="header" href="#fragment-specifiers">Fragment Specifiers</a></h1>
<p>As mentioned in the <a href="decl-macros/minutiae/../macros-methodical.html"><code>methodical introduction</code></a> chapter, Rust, as of 1.60, has 14 fragment specifiers.
This section will go a bit more into detail for some of them and shows a few example inputs of what each matcher matches.</p>
<blockquote>
<p><strong>Note</strong>: Capturing with anything but the <code>ident</code>, <code>lifetime</code> and <code>tt</code> fragments will render the captured AST opaque, making it impossible to further match it with other fragment specifiers in future macro invocations.</p>
</blockquote>
<ul>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#block"><code>block</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#expr"><code>expr</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#ident"><code>ident</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#item"><code>item</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#lifetime"><code>lifetime</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#literal"><code>literal</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#meta"><code>meta</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#pat"><code>pat</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#pat_param"><code>pat_param</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#path"><code>path</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#stmt"><code>stmt</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#tt"><code>tt</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#ty"><code>ty</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#vis"><code>vis</code></a></li>
</ul>
<h2 id="block"><a class="header" href="#block"><code>block</code></a></h2>
<p>The <code>block</code> fragment solely matches a <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">block expression</a>, which consists of an opening <code>{</code> brace, followed by any number of statements and finally followed by a closing <code>}</code> brace.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! blocks {
    ($($block:block)*) =&gt; ();
}

blocks! {
    {}
    {
        let zig;
    }
    { 2 }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="expr"><a class="header" href="#expr"><code>expr</code></a></h2>
<p>The <code>expr</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/expressions.html">expression</a> (Rust has a lot of them, given it <em>is</em> an expression-oriented language).</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! expressions {
    ($($expr:expr)*) =&gt; ();
}

expressions! {
    "literal"
    funcall()
    future.await
    break 'foo bar
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="ident"><a class="header" href="#ident"><code>ident</code></a></h2>
<p>The <code>ident</code> fragment matches an <a href="https://doc.rust-lang.org/reference/identifiers.html">identifier</a> or <em>keyword</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! idents {
    ($($ident:ident)*) =&gt; ();
}

idents! {
    // _ &lt;- This is not an ident, it is a pattern
    foo
    async
    O_________O
    _____O_____
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="item"><a class="header" href="#item"><code>item</code></a></h2>
<p>The <code>item</code> fragment simply matches any of Rust's <a href="https://doc.rust-lang.org/reference/items.html">item</a> <em>definitions</em>, not identifiers that refer to items.
This includes visibility modifiers.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! items {
    ($($item:item)*) =&gt; ();
}

items! {
    struct Foo;
    enum Bar {
        Baz
    }
    impl Foo {}
    pub use crate::foo;
    /*...*/
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="lifetime"><a class="header" href="#lifetime"><code>lifetime</code></a></h2>
<p>The <code>lifetime</code> fragment matches a <a href="https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels">lifetime or label</a>.
It's quite similar to <a href="decl-macros/minutiae/fragment-specifiers.html#ident"><code>ident</code></a> but with a prepended <code>'</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! lifetimes {
    ($($lifetime:lifetime)*) =&gt; ();
}

lifetimes! {
    'static
    'shiv
    '_
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="literal"><a class="header" href="#literal"><code>literal</code></a></h2>
<p>The <code>literal</code> fragment matches any <a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">literal expression</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! literals {
    ($($literal:literal)*) =&gt; ();
}

literals! {
    -1
    "hello world"
    2.3
    b'b'
    true
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="meta"><a class="header" href="#meta"><code>meta</code></a></h2>
<p>The <code>meta</code> fragment matches the contents of an <a href="https://doc.rust-lang.org/reference/attributes.html">attribute</a>.
That is, it will match a simple path, one without generic arguments followed by a delimited token tree or an <code>=</code> followed by a literal expression.</p>
<blockquote>
<p><strong>Note</strong>: You will usually see this fragment being used in a matcher like <code>#[$meta:meta]</code> or <code>#![$meta:meta]</code> to actually capture an attribute.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! metas {
    ($($meta:meta)*) =&gt; ();
}

metas! {
    ASimplePath
    super::man
    path = "home"
    foo(bar)
}
<span class="boring">fn main() {}</span></code></pre></pre>
<blockquote>
<p><strong>Doc-Comment Fact</strong>: Doc-Comments like <code>/// ...</code> and <code>//! ...</code> are actually syntax sugar for attributes! They desugar to <code>#[doc="..."]</code> and <code>#![doc="..."]</code> respectively, meaning you can match on them like with attributes!</p>
</blockquote>
<h2 id="pat"><a class="header" href="#pat"><code>pat</code></a></h2>
<p>The <code>pat</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/patterns.html">pattern</a>, including or-patterns starting with the 2021 edition.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! patterns {
    ($($pat:pat)*) =&gt; ();
}

patterns! {
    "literal"
    _
    0..5
    ref mut PatternsAreNice
    0 | 1 | 2 | 3
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="pat_param"><a class="header" href="#pat_param"><code>pat_param</code></a></h2>
<p>In the 2021 edition, the behavior for the <code>pat</code> fragment type has been changed to allow or-patterns to be parsed.
This changes the follow list of the fragment, preventing such fragment from being followed by a <code>|</code> token.
To avoid this problem or to get the old fragment behavior back one can use the <code>pat_param</code> fragment which allows <code>|</code> to follow it, as it disallows top level or-patterns.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! patterns {
    ($( $( $pat:pat_param )|+ )*) =&gt; ();
}

patterns! {
    "literal"
    _
    0..5
    ref mut PatternsAreNice
    0 | 1 | 2 | 3
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="path"><a class="header" href="#path"><code>path</code></a></h2>
<p>The <code>path</code> fragment matches a so called <a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types">TypePath</a> style path.
This includes the function style trait forms, <code>Fn() -&gt; ()</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! paths {
    ($($path:path)*) =&gt; ();
}

paths! {
    ASimplePath
    ::A::B::C::D
    G::&lt;eneri&gt;::C
    FnMut(u32) -&gt; ()
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="stmt"><a class="header" href="#stmt"><code>stmt</code></a></h2>
<p>The <code>statement</code> fragment solely matches a <a href="https://doc.rust-lang.org/reference/statements.html">statement</a> without its trailing semicolon, unless it is an item statement that requires one (such as a Unit-Struct).</p>
<p>Let's use a simple example to show exactly what is meant with this.
We use a macro that merely emits what it captures:</p>
<pre><code class="language-rust ignore">macro_rules! statements {
    ($($stmt:stmt)*) =&gt; ($($stmt)*);
}

fn main() {
    statements! {
        struct Foo;
        fn foo() {}
        let zig = 3
        let zig = 3;
        3
        3;
        if true {} else {}
        {}
    }
}
</code></pre>
<p>Expanding this, via the <a href="https://play.rust-lang.org/">playground</a> for example<sup class="footnote-reference" id="fr-debugging-1"><a href="#footnote-debugging">1</a></sup>, gives us roughly the following:</p>
<pre><code class="language-rust ignore">/* snip */

fn main() {
    struct Foo;
    fn foo() { }
    let zig = 3;
    let zig = 3;
    ;
    3;
    3;
    ;
    if true { } else { }
    { }
}</code></pre>
<p>From this we can tell a few things.</p>
<p>The first you should be able to see immediately is that while the <code>stmt</code> fragment doesn't capture trailing semicolons, it still emits them when required, even if the statement is already followed by one.
The simple reason for that is that semicolons on their own are already valid statements which the fragment captures eagerly.
So our macro isn't capturing 8 times, but 10!
This can be important when doing multiples repetitions and expanding these in one repetition expansion, as the repetition numbers have to match in those cases.</p>
<p>Another thing you should be able to notice here is that the trailing semicolon of the <code>struct Foo;</code> item statement is being matched, otherwise we would've seen an extra one like in the other cases.
This makes sense as we already said, that for item statements that require one, the trailing semicolon will be matched with.</p>
<p>A last observation is that expressions get emitted back with a trailing semicolon, unless the expression solely consists of only a block expression or control flow expression.</p>
<p>The fine details of what was just mentioned here can be looked up in the <a href="https://doc.rust-lang.org/reference/statements.html">reference</a>.</p>
<p>Fortunately, these fine details here are usually not of importance whatsoever, with the small exception that was mentioned earlier in regards to repetitions which by itself shouldn't be a common problem to run into.</p>
<h2 id="tt"><a class="header" href="#tt"><code>tt</code></a></h2>
<p>The <code>tt</code> fragment matches a TokenTree.
If you need a refresher on what exactly a TokenTree was you may want to revisit the <a href="decl-macros/minutiae/../../syntax-extensions/source-analysis.html#token-trees">TokenTree chapter</a> of this book.
The <code>tt</code> fragment is one of the most powerful fragments, as it can match nearly anything while still allowing you to inspect the contents of it at a later state in the macro.</p>
<p>This allows one to make use of very powerful patterns like the <a href="decl-macros/minutiae/../patterns/tt-muncher.html">tt-muncher</a> or the <a href="decl-macros/minutiae/../patterns/push-down-acc.html">push-down-accumulator</a>.</p>
<h2 id="ty"><a class="header" href="#ty"><code>ty</code></a></h2>
<p>The <code>ty</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/types.html#type-expressions">type expression</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! types {
    ($($type:ty)*) =&gt; ();
}

types! {
    foo::bar
    bool
    [u8]
    impl IntoIterator&lt;Item = u32&gt;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="vis"><a class="header" href="#vis"><code>vis</code></a></h2>
<p>The <code>vis</code> fragment matches a <em>possibly empty</em> <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility qualifier</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! visibilities {
    //         âˆ¨~~Note this comma, since we cannot repeat a `vis` fragment on its own
    ($($vis:vis,)*) =&gt; ();
}

visibilities! {
    , // no vis is fine, due to the implicit `?`
    pub,
    pub(crate),
    pub(in super),
    pub(in some_path),
}
<span class="boring">}</span></code></pre></pre>
<p>While able to match empty sequences of tokens, the fragment specifier still acts quite different from <a href="decl-macros/minutiae/../macros-methodical.html#repetitions">optional repetitions</a> which is described in the following:</p>
<p>If it is being matched against no left over tokens the entire macro matching fails.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! non_optional_vis {
    ($vis:vis) =&gt; ();
}
non_optional_vis!();
// ^^^^^^^^^^^^^^^^ error: missing tokens in macro arguments
<span class="boring">}</span></code></pre></pre>
<p><code>$vis:vis $ident:ident</code> matches fine.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! vis_ident {
    ($vis:vis $ident:ident) =&gt; ();
}
vis_ident!(pub foo); // this works fine
<span class="boring">}</span></code></pre></pre>
<p>In contrast, <code>$(pub)? $ident:ident</code> is ambiguous, as <code>pub</code> denotes a valid identifier.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! pub_ident {
    ($(pub)? $ident:ident) =&gt; ();
}
pub_ident!(pub foo);
        // ^^^ error: local ambiguity when calling macro `pub_ident`: multiple parsing options: built-in NTs ident ('ident') or 1 other option.
<span class="boring">}</span></code></pre></pre>
<p>Being a fragment that matches the empty token sequence also gives it a very interesting quirk in combination with <code>tt</code> fragments and recursive expansions.</p>
<p>When matching the empty token sequence, the metavariable will still count as a capture and since it is not a <code>tt</code>, <code>ident</code> or <code>lifetime</code> fragment it will become opaque to further expansions.
This means if this capture is passed onto another macro invocation that captures it as a <code>tt</code> you effectively end up with token tree that contains nothing!</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! it_is_opaque {
    (()) =&gt; { "()" };
    (($tt:tt)) =&gt; { concat!("$tt is ", stringify!($tt)) };
    ($vis:vis ,) =&gt; { it_is_opaque!( ($vis) ); }
}
fn main() {
    // this prints "$tt is ", as the recursive calls hits the second branch with
    // an empty tt, opposed to matching with the first branch!
    println!("{}", it_is_opaque!(,));
}</code></pre></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-debugging">
<p>See the <a href="decl-macros/minutiae/./debugging.html">debugging chapter</a> for tips on how to do this. <a href="#fr-debugging-1">â†©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="metavariables-and-expansion-redux"><a class="header" href="#metavariables-and-expansion-redux">Metavariables and Expansion Redux</a></h1>
<p>Once the parser begins consuming tokens for a metavariable, <em>it cannot stop or backtrack</em>.
This means that the second rule of the following macro <em>cannot ever match</em>, no matter what input is provided:</p>
<pre><code class="language-ignore">macro_rules! dead_rule {
    ($e:expr) =&gt; { ... };
    ($i:ident +) =&gt; { ... };
}
</code></pre>
<p>Consider what happens if this macro is invoked as <code>dead_rule!(x+)</code>.
The interpreter will start at the first rule, and attempt to parse the input as an expression.
The first token <code>x</code> is valid as an expression.
The second token is <em>also</em> valid in an expression, forming a binary addition node.</p>
<p>At this point, given that there is no right-hand side of the addition, you might expect the parser to give up and try the next rule.
Instead, the parser will panic and abort the entire compilation, citing a syntax error.</p>
<p>As such, it is important in general that you write macro rules from most-specific to least-specific.</p>
<p>To defend against future syntax changes altering the interpretation of macro input, <code>macro_rules!</code>
restricts what can follow various metavariables.
The complete list, showing what may follow what fragment specifier, as of Rust 1.46 is as follows:</p>
<ul>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#stmt"><code>stmt</code></a> and <a href="decl-macros/minutiae/./fragment-specifiers.html#expr"><code>expr</code></a>: <code>=&gt;</code>, <code>,</code>, or <code>;</code></li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#pat"><code>pat</code></a>: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, <code>in</code><sup class="footnote-reference" id="fr-pat-edition-1"><a href="#footnote-pat-edition">1</a></sup></li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#pat_param"><code>pat_param</code></a>: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code></li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#path"><code>path</code></a> and <a href="decl-macros/minutiae/./fragment-specifiers.html#ty"><code>ty</code></a>:<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a macro
variable of the <a href="decl-macros/minutiae/./fragment-specifiers.html#block"><code>block</code></a> fragment specifier.</li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#vis"><code>vis</code></a>: <code>,</code>, an identifier other than a non-raw <code>priv</code>, any token that can begin a type or a
metavariable with an <a href="decl-macros/minutiae/./fragment-specifiers.html#ident"><code>ident</code></a>, <a href="decl-macros/minutiae/./fragment-specifiers.html#ty"><code>ty</code></a>, or <a href="decl-macros/minutiae/./fragment-specifiers.html#path"><code>path</code></a> fragment specifier.</li>
<li>All other fragment specifiers have no restrictions.</li>
</ul>
<p>Repetitions also adhere to these restrictions, meaning if a repetition can repeat multiple times(<code>*</code> or <code>+</code>), then the contents must be able to follow themselves.
If a repetition can repeat zero times (<code>?</code> or <code>*</code>) then what comes after the repetition must be able to follow what comes before.</p>
<p>The parser also does not perform any kind of lookahead.
That means if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, it will abort with an ambiguity error.
A simple example that triggers this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $i2:ident) =&gt; { };
}

// error:
//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('i2').
ambiguity!(an_identifier);
<span class="boring">}</span></code></pre></pre>
<p>The parser does not look ahead past the identifier to see if the following token is a <code>)</code>, which would allow it to parse properly.</p>
<p>One aspect of substitution that often surprises people is that substitution is <em>not</em> token-based, despite very much <em>looking</em> like it.</p>
<p>Consider the following:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! capture_then_match_tokens {
    ($e:expr) =&gt; {match_tokens!($e)};
}

macro_rules! match_tokens {
    ($a:tt + $b:tt) =&gt; {"got an addition"};
    (($i:ident)) =&gt; {"got an identifier"};
    ($($other:tt)*) =&gt; {"got something else"};
}

fn main() {
    println!("{}\n{}\n{}\n",
        match_tokens!((caravan)),
        match_tokens!(3 + 6),
        match_tokens!(5));
    println!("{}\n{}\n{}",
        capture_then_match_tokens!((caravan)),
        capture_then_match_tokens!(3 + 6),
        capture_then_match_tokens!(5));
}</code></pre></pre>
<p>The output is:</p>
<pre><code class="language-text">got an identifier
got an addition
got something else

got something else
got something else
got something else
</code></pre>
<p>By parsing the input into an AST node, the substituted result becomes <em>un-destructible</em>;
<em>i.e.</em> you cannot examine the contents or match against it ever again.</p>
<p>Here is <em>another</em> example which can be particularly confusing:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {"no_mangle attribute"};
    (#[inline]) =&gt; {"inline attribute"};
    ($($tts:tt)*) =&gt; {concat!("something else (", stringify!($($tts)*), ")")};
}

fn main() {
    println!(
        "{}\n{}\n{}\n{}",
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]),
        capture_then_what_is!(#[inline]),
    );
}</code></pre></pre>
<p>The output is:</p>
<pre><code class="language-text">no_mangle attribute
inline attribute
something else (#[no_mangle])
something else (#[inline])
</code></pre>
<p>The only way to avoid this is to capture using the <a href="decl-macros/minutiae/./fragment-specifiers.html#tt"><code>tt</code></a>, <a href="decl-macros/minutiae/./fragment-specifiers.html#ident"><code>ident</code></a> or <a href="decl-macros/minutiae/./fragment-specifiers.html#lifetime"><code>lifetime</code></a> kinds.
Once you capture with anything else, the only thing you can do with the result from then on is substitute it directly into the output.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-pat-edition">
<p><strong>Edition Differences</strong>: Before the 2021 edition, <code>pat</code> may also be followed by <code>|</code>. <a href="#fr-pat-edition-1">â†©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="metavariable-expressions-1"><a class="header" href="#metavariable-expressions-1">Metavariable Expressions</a></h1>
<blockquote>
<p><em>RFC</em>: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md">rfcs#1584</a><br />
<em>Tracking Issue</em>: <a href="https://github.com/rust-lang/rust/issues/83527">rust#83527</a><br />
<em>Feature</em>: <code>#![feature(macro_metavar_expr)]</code></p>
</blockquote>
<blockquote>
<p>Note: The example code snippets are very bare bones, trying to show off how they work. If you think you got small snippets with proper isolated usage of these expression please submit them!</p>
</blockquote>
<p>As mentioned in the <a href="decl-macros/minutiae/../macros-methodical.html"><code>methodical introduction</code></a>, Rust has special expressions that can be used by macro transcribers to obtain information about metavariables that are otherwise difficult or even impossible to get.
This chapter will introduce them more in-depth together with usage examples.</p>
<ul>
<li><a href="decl-macros/minutiae/metavar-expr.html#metavariable-expressions">Metavariable Expressions</a>
<ul>
<li><a href="decl-macros/minutiae/metavar-expr.html#dollar-dollar-">Dollar Dollar (<code>$$</code>)</a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#countident-depth"><code>count($ident, depth)</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#indexdepth"><code>index(depth)</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#lengthdepth"><code>len(depth)</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#ignoreident"><code>ignore($ident)</code></a></li>
</ul>
</li>
</ul>
<h2 id="dollar-dollar-"><a class="header" href="#dollar-dollar-">Dollar Dollar (<code>$$</code>)</a></h2>
<p>The <code>$$</code> expression expands to a single <code>$</code>, making it effectively an escaped <code>$</code>.
This enables the ability in writing macros emitting new macros as the former macro won't transcribe metavariables, repetitions and metavariable expressions that have an escaped <code>$</code>.</p>
<p>We can see the problem without using <code>$$</code> in the following snippet:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! foo {
    () =&gt; {
        macro_rules! bar {
            ( $( $any:tt )* ) =&gt; { $( $any )* };
            // ^^^^^^^^^^^ error: attempted to repeat an expression containing no syntax variables matched as repeating at this depth
        }
    };
}

foo!();
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The problem is obvious, the transcriber of foo sees a repetition and tries to repeat it when transcribing, but there is no <code>$any</code> metavariable in its scope causing it to fail.
With <code>$$</code> we can get around this as the transcriber of <code>foo</code> will no longer try to do the repetition.<sup class="footnote-reference" id="fr-tt-$-1"><a href="#footnote-tt-$">1</a></sup></p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(macro_metavar_expr)]

macro_rules! foo {
    () =&gt; {
        macro_rules! bar {
            ( $$( $$any:tt )* ) =&gt; { $$( $$any )* };
        }
    };
}

foo!();
bar!();
<span class="boring">fn main() {}</span></code></pre>
<h2 id="countident-depth"><a class="header" href="#countident-depth"><code>count($ident, depth)</code></a></h2>
<p>The <code>count</code> metavariable expression expands to the repetition count of the metavariable <code>$ident</code> up to the given repetition depth.</p>
<ul>
<li>The <code>$ident</code> argument must be a declared metavariable in the scope of the rule.</li>
<li>The <code>depth</code> argument must be an integer literal of value less or equal to the maximum repetition depth that the <code>$ident</code> metavariable appears in.</li>
<li>The expression expands to an unsuffixed integer literal token.</li>
</ul>
<p>The <code>count($ident)</code> expression defaults <code>depth</code> to the maximum valid depth, making it count the total repetitions for the given metavariable.</p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(macro_metavar_expr)]

macro_rules! foo {
    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) =&gt; {
        println!("count(outer, 0): $outer repeats {} times", ${count($outer)});
        println!("count(inner, 0): The $inner repetition repeats {} times in the outer repetition", ${count($inner, 0)});
        println!("count(inner, 1): $inner repeats {} times in the inner repetitions", ${count($inner, 1)});
    };
}

fn main() {
    foo! {
        outer () ;
        outer ( inner , inner ) ;
        outer () ;
        outer ( inner ) ;
    };
}</code></pre>
<h2 id="indexdepth"><a class="header" href="#indexdepth"><code>index(depth)</code></a></h2>
<p>The <code>index(depth)</code> metavariable expression expands to the current iteration index of the repetition at the given depth.</p>
<ul>
<li>The <code>depth</code> argument targets the repetition at <code>depth</code> counting outwards from the inner-most repetition where the expression is invoked.</li>
<li>The expression expands to an unsuffixed integer literal token.</li>
</ul>
<p>The <code>index()</code> expression defaults <code>depth</code> to <code>0</code>, making it a shorthand for <code>index(0)</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(macro_metavar_expr)]

macro_rules! attach_iteration_counts {
    ( $( ( $( $inner:ident ),* ) ; )* ) =&gt; {
        ( $(
            $((
                stringify!($inner),
                ${index(1)}, // this targets the outer repetition
                ${index()}  // and this, being an alias for `index(0)` targets the inner repetition
            ),)*
        )* )
    };
}

fn main() {
    let v = attach_iteration_counts! {
        ( hello ) ;
        ( indices , of ) ;
        () ;
        ( these, repetitions ) ;
    };
    println!("{v:?}");
}</code></pre>
<h2 id="lendepth"><a class="header" href="#lendepth"><code>len(depth)</code></a></h2>
<p>The <code>len(depth)</code> metavariable expression expands to the iteration count of the repetition at the given depth.</p>
<ul>
<li>The <code>depth</code> argument targets the repetition at <code>depth</code> counting outwards from the inner-most repetition where the expression is invoked.</li>
<li>The expression expands to an unsuffixed integer literal token.</li>
</ul>
<p>The <code>len()</code> expression defaults <code>depth</code> to <code>0</code>, making it a shorthand for <code>len(0)</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(macro_metavar_expr)]

macro_rules! lets_count {
    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) =&gt; {
        $(
            $(
                println!(
                    "'{}' in inner iteration {}/{} with '{}' in outer iteration {}/{} ",
                    stringify!($inner), ${index()}, ${len()},
                    stringify!($outer), ${index(1)}, ${len(1)},
                );
            )*
        )*
    };
}

fn main() {
    lets_count!(
        many (small , things) ;
        none () ;
        exactly ( one ) ;
    );
}</code></pre>
<h2 id="ignoreident"><a class="header" href="#ignoreident"><code>ignore($ident)</code></a></h2>
<p>The <code>ignore($ident)</code> metavariable expression expands to nothing, making it possible to expand something as often as a metavariable repeats without expanding the metavariable.</p>
<ul>
<li>The <code>$ident</code> argument must be a declared metavariable in the scope of the rule.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(macro_metavar_expr)]

macro_rules! repetition_tuples {
    ( $( ( $( $inner:ident ),* ) ; )* ) =&gt; {
        ($(
            $(
                (
                    ${index()},
                    ${index(1)}
                    ${ignore($inner)} // without this metavariable expression, compilation would fail
                ),
            )*
        )*)
    };
}

fn main() {
    let tuple = repetition_tuples!(
        ( one, two ) ;
        () ;
        ( one ) ;
        ( one, two, three ) ;
    );
    println!("{tuple:?}");
}</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-tt-$">
<p>Before <code>$$</code> was implemented, users had to resort to a tricky and not so well-known hack to declare nested macros with repetitions
<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9ce18fc79ce17c77d20e74f3c46ee13c">via using <code>$tt</code> like this</a>. <a href="#fr-tt-$-1">â†©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="hygiene-1"><a class="header" href="#hygiene-1">Hygiene</a></h1>
<p><code>macro_rules!</code> macros in Rust are <em>partially</em> hygienic, also called mixed hygiene.
Specifically, they are hygienic when it comes to <em>local variables</em>, <em>labels</em> and <code>$crate</code>, but nothing else.</p>
<p>Hygiene works by attaching an invisible "syntax context" value to all identifiers.
When two identifiers are compared, <em>both</em> the identifiers' textual names <em>and</em> syntax contexts must be identical for the two to be considered equal.</p>
<p>To illustrate this, consider the following code:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-built_in">macro_rules</span><span class="hljs-built_in">!</span> using_a {&#xa;    ($e:expr) =&gt; {&#xa;        {&#xa;            <span class="hljs-keyword">let</span> a = <span class="hljs-number">42</span>;&#xa;            $e&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="hljs-keyword">let</span> four = <span class="hljs-built_in">using_a!</span>(a / <span class="hljs-number">10</span>);</span></pre>
<p>We will use the background colour to denote the syntax context.
Now, let's expand the macro invocation:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-keyword">let</span> four = </span><span class="synctx-1">{&#xa;    <span class="hljs-keyword">let</span> a <span class="op">=</span> <span class="hljs-number">42</span>;&#xa;    </span><span class="synctx-0">a / <span class="hljs-number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>First, recall that <code>macro_rules!</code> invocations effectively <em>disappear</em> during expansion.</p>
<p>Second, if you attempt to compile this code, the compiler will respond with something along the following lines:</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:13:21
   |
13 | let four = using_a!(a / 10);
   |                     ^ not found in this scope
</code></pre>
<p>Note that the background colour (<em>i.e.</em> syntax context) for the expanded macro <em>changes</em> as part of expansion.
Each <code>macro_rules!</code> macro expansion is given a new, unique syntax context for its contents.
As a result, there are <em>two different <code>a</code>s</em> in the expanded code: one in the first syntax context, the second in the other.
In other words, <code><span class="synctx-0">a</span></code> is not the same identifier as <code><span class="synctx-1">a</span></code>, however similar they may appear.</p>
<p>That said, tokens that were substituted <em>into</em> the expanded output <em>retain</em> their original syntax context (by virtue of having been provided to the macro as opposed to being part of the macro itself).
Thus, the solution is to modify the macro as follows:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-built_in">macro_rules!</span> using_a {&#xa;    ($a:ident, $e:expr) =&gt; {&#xa;        {&#xa;            <span class="hljs-keyword">let</span> $a = <span class="hljs-number">42</span>;&#xa;            $e&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="hljs-keyword">let</span> four = <span class="hljs-built_in">using_a!</span>(a, a / <span class="hljs-number">10</span>);</span></pre>
<p>Which, upon expansion becomes:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-keyword">let</span> four = </span><span class="synctx-1">{&#xa;    <span class="hljs-keyword">let</span> </span><span class="synctx-0">a</span><span class="synctx-1"> = <span class="hljs-number">42</span>;&#xa;    </span><span class="synctx-0">a / <span class="hljs-number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>The compiler will accept this code because there is only one <code>a</code> being used.</p>
<h3 id="crate"><a class="header" href="#crate"><code>$crate</code></a></h3>
<p>Hygiene is also the reason that we need the <code>$crate</code> metavariable when our macro needs access to other items in the defining crate.
What this special metavariable does is that it expands to an absolute path to the defining crate.</p>
<pre><code class="language-rust ignore">//// Definitions in the `helper_macro` crate.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// Usage in another crate.
// Note that `helper_macro::helper` is not imported!
use helper_macro::helped;

fn unit() {
   // but it still works due to `$crate` properly expanding to the crate path `helper_macro`
   helped!();
}</code></pre>
<p>Note that, because <code>$crate</code> refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-identifier-identifiers"><a class="header" href="#non-identifier-identifiers">Non-Identifier Identifiers</a></h1>
<p>There are two tokens which you are likely to run into eventually that <em>look</em> like identifiers, but aren't.
Except when they are.</p>
<p>First is <code>self</code>.
This is <em>very definitely</em> a keyword.
However, it also happens to fit the definition of an identifier.
In regular Rust code, there's no way for <code>self</code> to be interpreted as an identifier, but it <em>can</em> happen with <code>macro_rules!</code> macros:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! what_is {
    (self) =&gt; {"the keyword `self`"};
    ($i:ident) =&gt; {concat!("the identifier `", stringify!($i), "`")};
}

macro_rules! call_with_ident {
    ($c:ident($i:ident)) =&gt; {$c!($i)};
}

fn main() {
    println!("{}", what_is!(self));
    println!("{}", call_with_ident!(what_is(self)));
}</code></pre></pre>
<p>The above outputs:</p>
<pre><code class="language-text">the keyword `self`
the keyword `self`
</code></pre>
<p>But that makes no sense; <code>call_with_ident!</code> required an identifier, matched one, and substituted it!
So <code>self</code> is both a keyword and not a keyword at the same time.
You might wonder how this is in any way important.
Take this example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! make_mutable {
    ($i:ident) =&gt; {let mut $i = $i;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_mutable!(self);
        self.0 *= 2;
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("{:?}", Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>This fails to compile with:</p>
<pre><code class="language-text">error: `mut` must be followed by a named binding
 --&gt; src/main.rs:2:24
  |
2 |     ($i:ident) =&gt; {let mut $i = $i;};
  |                        ^^^^^^ help: remove the `mut` prefix: `self`
...
9 |         make_mutable!(self);
  |         -------------------- in this macro invocation
  |
  = note: `mut` may be followed by `variable` and `variable @ pattern`
</code></pre>
<p>So the macro will happily match <code>self</code> as an identifier, allowing you to use it in cases where you can't actually use it.
But, fine; it somehow remembers that <code>self</code> is a keyword even when it's an identifier, so you <em>should</em> be able to do this, right?</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! make_self_mutable {
    ($i:ident) =&gt; {let mut $i = self;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_self_mutable!(mut_self);
        mut_self.0 *= 2;
        mut_self
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("{:?}", Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>This fails with:</p>
<pre><code class="language-text">error[E0424]: expected value, found module `self`
  --&gt; src/main.rs:2:33
   |
2  |       ($i:ident) =&gt; {let mut $i = self;};
   |                                   ^^^^ `self` value is a keyword only available in methods with a `self` parameter
...
8  | /     fn double(self) -&gt; Dummy {
9  | |         make_self_mutable!(mut_self);
   | |         ----------------------------- in this macro invocation
10 | |         mut_self.0 *= 2;
11 | |         mut_self
12 | |     }
   | |_____- this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters
   |
</code></pre>
<p>Now the compiler thinks we refer to our module with <code>self</code>, but that doesn't make sense.
We already have a <code>self</code> right there, in the function signature which is definitely not a module.
It's almost like it's complaining that the <code>self</code> it's trying to use isn't the <em>same</em> <code>self</code>... as though the <code>self</code> keyword has hygiene, like an... identifier.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! double_method {
    ($body:expr) =&gt; {
        fn double(mut self) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {{
        self.0 *= 2;
        self
    }}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("{:?}", Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>Same error.  What about...</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double(mut $self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {self, {
        self.0 *= 2;
        self
    }}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("{:?}", Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>At last, <em>this works</em>.
So <code>self</code> is both a keyword <em>and</em> an identifier when it feels like it.
Surely this works for other, similar constructs, right?</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double($self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {_, 0}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("{:?}", Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error: no rules expected the token `_`
  --&gt; src/main.rs:12:21
   |
1  | macro_rules! double_method {
   | -------------------------- when calling this macro
...
12 |     double_method! {_, 0}
   |                     ^ no rules expected this token in macro call
</code></pre>
<p>No, of course not.
<code>_</code> is a keyword that is valid in patterns and expressions, but somehow <em>isn't</em> an identifier like the keyword <code>self</code> is, despite matching the definition of an identifier just the same.</p>
<p>You might think you can get around this by using <code>$self_:pat</code> instead; that way, <code>_</code> will match! Except, no, because <code>self</code> isn't a pattern.
Joy.</p>
<p>The only work around for this (in cases where you want to accept some combination of these tokens) is to use a <a href="decl-macros/minutiae/./fragment-specifiers.html#tt"><code>tt</code></a> matcher instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h1>
<blockquote>
<p><strong>Note</strong>: This is a list of debugging tools specifically tailored towards declarative macros, additional means of debugging these can be found in the <a href="decl-macros/minutiae/../../syntax-extensions/debugging.html">debugging chapter</a> of syntax extensions.</p>
</blockquote>
<p>One of the most useful is <a href="https://doc.rust-lang.org/std/macro.trace_macros.html"><code>trace_macros!</code></a>, which is a directive to the compiler instructing it to dump every <code>macro_rules!</code> macro invocation prior to expansion.
For example, given the following:</p>
<pre><code class="language-rust ignore"><span class="boring">// Note: make sure to use a nightly channel compiler.
</span>#![feature(trace_macros)]

macro_rules! each_tt {
    () =&gt; {};
    ($_tt:tt $($rest:tt)*) =&gt; {each_tt!($($rest)*);};
}

each_tt!(foo bar baz quux);
trace_macros!(true);
each_tt!(spim wak plee whum);
trace_macros!(false);
each_tt!(trom qlip winp xod);
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>The output is:</p>
<pre><code class="language-text">note: trace_macro
  --&gt; src/main.rs:11:1
   |
11 | each_tt!(spim wak plee whum);
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: expanding `each_tt! { spim wak plee whum }`
   = note: to `each_tt ! (wak plee whum) ;`
   = note: expanding `each_tt! { wak plee whum }`
   = note: to `each_tt ! (plee whum) ;`
   = note: expanding `each_tt! { plee whum }`
   = note: to `each_tt ! (whum) ;`
   = note: expanding `each_tt! { whum }`
   = note: to `each_tt ! () ;`
   = note: expanding `each_tt! {  }`
   = note: to ``
</code></pre>
<p>This is <em>particularly</em> invaluable when debugging deeply recursive <code>macro_rules!</code> macros.
You can also enable this from the command-line by adding <code>-Z trace-macros</code> to the compiler command line.</p>
<p>Secondly, there is <a href="https://doc.rust-lang.org/std/macro.log_syntax.html"><code>log_syntax!</code></a> which causes the compiler to output all tokens passed to it.
For example, this makes the compiler sing a song:</p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(log_syntax)]

macro_rules! sing {
    () =&gt; {};
    ($tt:tt $($rest:tt)*) =&gt; {log_syntax!($tt); sing!($($rest)*);};
}

sing! {
    ^ &lt; @ &lt; . @ *
    '\x08' '{' '"' _ # ' '
    - @ '$' &amp;&amp; / _ %
    ! ( '\t' @ | = &gt;
    ; '\x08' '\'' + '$' ? '\x7f'
    , # '"' ~ | ) '\x07'
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>This can be used to do slightly more targeted debugging than <a href="https://doc.rust-lang.org/std/macro.trace_macros.html"><code>trace_macros!</code></a>.</p>
<p>Another amazing tool is <a href="https://github.com/lukaslueg"><code>lukaslueg</code>'s</a> <a href="https://github.com/lukaslueg/macro_railroad"><code>macro_railroad</code></a>, a tool that allows you visualize and generate syntax diagrams for Rust's <code>macro_rules!</code> macros.
It visualizes the accepted macro's grammar as an automata.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoping"><a class="header" href="#scoping">Scoping</a></h1>
<p>The way in which mbe macros are scoped can be somewhat unintuitive.
They use two forms of scopes: textual scope, and path-based scope.</p>
<p>When such a macro is invoked by an unqualified identifier(an identifier that isn't part of a multi-segment path), it is first looked up in textual scoping and then in path-based scoping should the first lookup not yield any results.
If it is invoked by a qualified identifier it will skip the textual scoping lookup and instead only do a look up in the path-based scoping.</p>
<h2 id="textual-scope"><a class="header" href="#textual-scope">Textual Scope</a></h2>
<p>Firstly, unlike everything else in the language, function-like macros will remain visible in sub-modules.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! X { () =&gt; {}; }
mod a {
    X!(); // defined
}
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: In these examples, remember that all of them have the <em>same behavior</em> when the module contents are in separate files.</p>
</blockquote>
<p>Secondly, <em>also</em> unlike everything else in the language, <code>macro_rules!</code> macros are only accessible <em>after</em> their definition.
Also note that this example demonstrates how <code>macro_rules!</code> macros do not "leak" out of their defining scope:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    // X!(); // undefined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>To be clear, this lexical order dependency applies even if you move the macro to an outer scope:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; {}; }
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>However, this dependency <em>does not</em> apply to macros themselves:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; { Y!(); }; }
mod b {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Defining <code>macro_rules!</code> macros multiple times is allowed and the most recent declaration will simply shadow previous ones unless it has gone out of scope.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! X { (1) =&gt; {}; }
X!(1);
macro_rules! X { (2) =&gt; {}; }
// X!(1); // Error: no rule matches `1`
X!(2);

mod a {
    macro_rules! X { (3) =&gt; {}; }
    // X!(2); // Error: no rule matches `2`
    X!(3);
}
// X!(3); // Error: no rule matches `3`
X!(2);

<span class="boring">}</span></code></pre></pre>
<p><code>macro_rules!</code> macros can be exported from a module using the <code>#[macro_use]</code> attribute.
Using this on a module is similar to saying that you do not want to have the module's macro's scope end with the module.</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Note that this can interact in somewhat bizarre ways due to the fact that identifiers in a <code>macro_rules!</code> macro (including other macros) are only resolved upon expansion:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; { Y!(); }; }
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Another complication is that <code>#[macro_use]</code> applied to an <code>extern crate</code> <em>does not</em> behave this way: such declarations are effectively <em>hoisted</em> to the top of the module. Thus, assuming <code>X!</code> is defined in an external crate called <code>macs</code>, the following holds:</p>
<pre><code class="language-rust ignore">mod a {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod b {
    X!(); // defined, and so is Y!
}
#[macro_use] extern crate macs;
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}</span></code></pre>
<p>Finally, note that these scoping behaviors apply to <em>functions</em> as well, with the exception of <code>#[macro_use]</code> (which isn't applicable):</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! X {
    () =&gt; { Y!() };
}

fn a() {
    macro_rules! Y { () =&gt; {"Hi!"} }
    assert_eq!(X!(), "Hi!");
    {
        assert_eq!(X!(), "Hi!");
        macro_rules! Y { () =&gt; {"Bye!"} }
        assert_eq!(X!(), "Bye!");
    }
    assert_eq!(X!(), "Hi!");
}

fn b() {
    macro_rules! Y { () =&gt; {"One more"} }
    assert_eq!(X!(), "One more");
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    a();
</span><span class="boring">    b();
</span><span class="boring">}</span></code></pre></pre>
<p>These scoping rules are why a common piece of advice is to place all <code>macro_rules!</code> macros which should be accessible "crate wide" at the very top of your root module, before any other modules.
This ensures they are available <em>consistently</em>.
This also applies to <code>mod</code> definitions for files, as in:</p>
<pre><code class="language-rs">#[macro_use]
mod some_mod_that_defines_macros;
mod some_mod_that_uses_those_macros;
</code></pre>
<p>The order here is important, swap the declaration order and it won't compile.</p>
<h2 id="path-based-scope"><a class="header" href="#path-based-scope">Path-Based Scope</a></h2>
<p>By default, a <code>macro_rules!</code> macro has no path-based scope.
However, if it has the <code>#[macro_export]</code> attribute, then it is declared in the crate root scope and can be referred to similar to how you refer to any other item.
The <a href="decl-macros/minutiae/./import-export.html">Import and Export</a> chapter goes more in-depth into said attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-and-export"><a class="header" href="#import-and-export">Import and Export</a></h1>
<p>Importing <code>macro_rules!</code> macros differs between the two Rust Editions, 2015 and 2018.
It is recommended to read both parts nevertheless, as the 2018 Edition can still use the constructs that are explained in the 2015 Edition.</p>
<h2 id="edition-2015"><a class="header" href="#edition-2015">Edition 2015</a></h2>
<p>In Edition 2015 you have to use the <code>#[macro_use]</code> attribute that has already been introduced in the <a href="decl-macros/minutiae/./scoping.html">scoping chapter</a>.
This can be applied to <em>either</em> modules or external crates.
For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_use]
mod macros {
    macro_rules! X { () =&gt; { Y!(); } }
    macro_rules! Y { () =&gt; {} }
}

X!();
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><code>macro_rules!</code> macros can be exported from the current crate using <code>#[macro_export]</code>.
Note that this <em>ignores</em> all visibility.</p>
<p>Given the following definition for a library package <code>macs</code>:</p>
<pre><code class="language-rust ignore">mod macros {
    #[macro_export] macro_rules! X { () =&gt; { Y!(); } }
    #[macro_export] macro_rules! Y { () =&gt; {} }
}

// X! and Y! are *not* defined here, but *are* exported,
// despite `macros` being private.</code></pre>
<p>The following code will work as expected:</p>
<pre><code class="language-rust ignore">X!(); // X is defined
#[macro_use] extern crate macs;
X!();
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>This works, as said in the <a href="decl-macros/minutiae/./scoping.html">scoping chapter</a>, because <code>#[macro_use]</code> works slightly different on extern crates, as it basically <em>hoists</em> the exported macros out of the crate to the top of the module.</p>
<blockquote>
<p>Note: you can <em>only</em> <code>#[macro_use]</code> an external crate from the root module.</p>
</blockquote>
<p>Finally, when importing <code>macro_rules!</code> macros from an external crate, you can control <em>which</em> macros you import.
You can use this to limit namespace pollution, or to override specific macros, like so:</p>
<pre><code class="language-rust ignore">// Import *only* the `X!` macro.
#[macro_use(X)] extern crate macs;

// X!(); // X is defined, but Y! is undefined

macro_rules! Y { () =&gt; {} }

X!(); // X is defined, and so is Y!

fn main() {}</code></pre>
<p>When exporting <code>macro_rules!</code> macros, it is often useful to refer to non-macro symbols in the defining crate.
Because crates can be renamed, there is a special substitution variable available: <a href="decl-macros/minutiae/./hygiene.html#crate"><code>$crate</code></a>.
This will <em>always</em> expand to an absolute path prefix to the containing crate (<em>e.g.</em> <code>:: macs</code>).</p>
<p>Note that unless your compiler version is &gt;= 1.30, this does <em>not</em> work for <code>macro_rules!</code> macros, because <code>macro_rules!</code> macros do not interact with regular name resolution in any way.
Otherwise, you cannot use something like <code>$crate::Y!</code> to refer to a particular macro within your crate.
The implication, combined with selective imports via <code>#[macro_use]</code> is that there is currently <em>no way</em> to guarantee any given macro will be available when imported by another crate.</p>
<p>It is recommended that you <em>always</em> use absolute paths to non-macro names, to avoid conflicts, <em>including</em> names in the standard library.</p>
<h2 id="edition-2018"><a class="header" href="#edition-2018">Edition 2018</a></h2>
<p>The 2018 Edition made our lives a lot easier when it comes to <code>macro_rules!</code> macros.
Why you ask?
Quite simply because it managed to make them feel more like proper items than some special thing in the language.
What this means is that we can properly import and use them in a namespaced fashion!</p>
<p>So instead of using <code>#[macro_use]</code> to import every exported macro from a crate into the global namespace we can now do the following:</p>
<pre><code class="language-rs">use some_crate::some_macro;

fn main() {
    some_macro!("hello");
    // as well as
    some_crate::some_other_macro!("macro world");
}
</code></pre>
<p>Unfortunately, this only applies for external crates, if you use <code>macro_rules!</code> macros that you have defined in your own crate you are still required to go with <code>#[macro_use]</code> on the defining modules.
So scoping applies there the same way as before as well.</p>
<blockquote>
<p>The <code>$crate</code> prefix works in this version for everything, macros and items alike since this Edition came out with Rust 1.31.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<p>Parsing and expansion patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>Due to the order that macros are expanded in, it is (as of Rust 1.2) impossible to pass information to a macro from the expansion of <em>another</em> macro:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recognize_tree {
    (larch) =&gt; { println!("#1, the Larch.") };
    (redwood) =&gt; { println!("#2, the Mighty Redwood.") };
    (fir) =&gt; { println!("#3, the Fir.") };
    (chestnut) =&gt; { println!("#4, the Horse Chestnut.") };
    (pine) =&gt; { println!("#5, the Scots Pine.") };
    ($($other:tt)*) =&gt; { println!("I don't know; some kind of birch maybe?") };
}

macro_rules! expand_to_larch {
    () =&gt; { larch };
}

fn main() {
    recognize_tree!(expand_to_larch!());
    // first expands to:  recognize_tree! { expand_to_larch ! (  ) }
    // and then:          println! { "I don't know; some kind of birch maybe?" }
}</code></pre></pre>
<p>This can make modularizing macros very difficult.</p>
<p>An alternative is to use recursion and pass a callback:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// ...
<span class="boring">macro_rules! recognize_tree {
</span><span class="boring">    (larch) =&gt; { println!("#1, the Larch.") };
</span><span class="boring">    (redwood) =&gt; { println!("#2, the Mighty Redwood.") };
</span><span class="boring">    (fir) =&gt; { println!("#3, the Fir.") };
</span><span class="boring">    (chestnut) =&gt; { println!("#4, the Horse Chestnut.") };
</span><span class="boring">    (pine) =&gt; { println!("#5, the Scots Pine.") };
</span><span class="boring">    ($($other:tt)*) =&gt; { println!("I don't know; some kind of birch maybe?") };
</span><span class="boring">}
</span>
macro_rules! call_with_larch {
    ($callback:ident) =&gt; { $callback!(larch) };
}

fn main() {
    call_with_larch!(recognize_tree);
    // first expands to:  call_with_larch! { recognize_tree }
    // then:              recognize_tree! { larch }
    // and finally:       println! { "#1, the Larch." }
}</code></pre></pre>
<p>Using a <code>tt</code> repetition, one can also forward arbitrary arguments to a callback.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! callback {
    ($callback:ident( $($args:tt)* )) =&gt; {
        $callback!( $($args)* )
    };
}

fn main() {
    callback!(callback(println("Yes, this *was* unnecessary.")));
}</code></pre></pre>
<p>You can, of course, insert additional tokens in the arguments as needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incremental-tt-munchers"><a class="header" href="#incremental-tt-munchers">Incremental TT Munchers</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! mixed_rules {
    () =&gt; {};
    (trace $name:ident; $($tail:tt)*) =&gt; {
        {
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
    (trace $name:ident = $init:expr; $($tail:tt)*) =&gt; {
        {
            let $name = $init;
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let a = 42;
</span><span class="boring">    let b = "Ho-dee-oh-di-oh-di-oh!";
</span><span class="boring">    let c = (false, 2, 'c');
</span><span class="boring">    mixed_rules!(
</span><span class="boring">        trace a;
</span><span class="boring">        trace b;
</span><span class="boring">        trace c;
</span><span class="boring">        trace b = "They took her where they put the crazies.";
</span><span class="boring">        trace b;
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p>This pattern is perhaps the <em>most powerful</em> macro parsing technique available, allowing one to parse grammars of significant complexity.
However, it can increase compile times if used excessively, so should be used
with care.</p>
<p>A <em>TT muncher</em> is a recursive <code>macro_rules!</code> macro that works by incrementally processing its input one step at a time.
At each step, it matches and removes (munches) some sequence of tokens from the start of its input, generates some intermediate output, then recurses on the input tail.</p>
<p>The reason for "TT" in the name specifically is that the unprocessed part of the input is <em>always</em> captured as <code>$($tail:tt)*</code>.
This is done as a <a href="decl-macros/patterns/../minutiae/fragment-specifiers.html#tt"><code>tt</code></a> repetition is the only way to <em>losslessly</em> capture part of a macro's input.</p>
<p>The only hard restrictions on TT munchers are those imposed on the <code>macro_rules!</code> macro system as a whole:</p>
<ul>
<li>You can only match against literals and grammar constructs which can be captured by <code>macro_rules!</code>.</li>
<li>You cannot match unbalanced groups.</li>
</ul>
<p>It is important, however, to keep the macro recursion limit in mind.
<code>macro_rules!</code> does not have <em>any</em> form of tail recursion elimination or optimization.
It is recommended that, when writing a TT muncher, you make reasonable efforts to keep recursion as limited as possible.
This can be done by adding additional rules to account for variation in the input (as opposed to recursion into an intermediate layer), or by making compromises on the input syntax to make using standard repetitions more tractable.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>TT munchers are inherently quadratic.
Consider a TT muncher rule that consumes one token tree and then recursively calls itself on the remaining input.
If it is passed 100 token trees:</p>
<ul>
<li>The initial invocation will match against all 100 token trees.</li>
<li>The first recursive invocation will match against 99 token trees.</li>
<li>The next recursive invocation will match against 98 token trees.</li>
</ul>
<p>And so on, down to 1.
This is a classic quadratic pattern, and long inputs can cause macro expansion to blow out compile times.</p>
<p>Try to avoid using TT munchers too much, especially with long inputs.
The default value of the <code>recursion_limit</code> attribute is a good sanity check; if you have to exceed it, you might be heading for trouble.</p>
<p>If you have the choice between writing a TT muncher that can be called once to handle multiple things, or a simpler macro that can be called multiple times to handle a single thing, prefer the latter.
For example, you could change a macro that is called like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! f { ($($tt:tt)*) =&gt; {} }
</span>f! {
    fn f_u8(x: u32) -&gt; u8;
    fn f_u16(x: u32) -&gt; u16;
    fn f_u32(x: u32) -&gt; u32;
    fn f_u64(x: u64) -&gt; u64;
    fn f_u128(x: u128) -&gt; u128;
}
<span class="boring">}</span></code></pre></pre>
<p>To one that is called like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! f { ($($tt:tt)*) =&gt; {} }
</span>f! { fn f_u8(x: u32) -&gt; u8; }
f! { fn f_u16(x: u32) -&gt; u16; }
f! { fn f_u32(x: u32) -&gt; u32; }
f! { fn f_u64(x: u64) -&gt; u64; }
f! { fn f_u128(x: u128) -&gt; u128; }
<span class="boring">}</span></code></pre></pre>
<p>The longer the input, the more likely this will improve compile times.</p>
<p>Also, if a TT muncher macro has many rules, put the most frequently matched
rules as early as possible.
This avoids unnecessary matching failures.
(In fact, this is good advice for any kind of declarative macro, not just TT munchers.)</p>
<p>Finally, if you can write a macro using normal repetition via <code>*</code> or <code>+</code>, that should be preferred to a TT muncher.
This is most likely if each invocation of the TT muncher would only process one token at a time.
In more complicated cases, there is an advanced technique used within the <code>quote</code> crate that can avoid the quadratic behaviour, at the cost of some conceptual complexity.
See <a href="https://github.com/dtolnay/quote/blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib.rs#L664-L746">this comment</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-rules"><a class="header" href="#internal-rules">Internal Rules</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e};

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}</span></code></pre></pre>
<p>Internal rules can be used to unify multiple <code>macro_rules!</code> macros into one, or to make it easier to read and write <a href="decl-macros/patterns/./tt-muncher.html">TT Munchers</a> by explicitly naming what rule you wish to call in a macro.</p>
<p>So why is it useful to unify multiple macros-by-example into one?
The main reasoning for this is how they are handled in the 2015 Edition of Rust due to <code>macro_rules!</code> macros not being namespaced in said edition.
This gives one the troubles of having to re-export all the internal <code>macro_rules!</code> macros as well as polluting the global macro namespace or even worse, macro name collisions with other crates.
In short, it's quite a hassle.
This fortunately isn't really a problem anymore nowadays with a rustc version &gt;= 1.30, for more information consult the <a href="decl-macros/patterns/../minutiae/import-export.html">Import and Export chapter</a>.</p>
<p>Nevertheless, let's talk about how we can unify multiple <code>macro_rules!</code> macros into one with this technique and what exactly this technique even is.</p>
<p>We have two <code>macro_rules!</code> macros, the common <a href="decl-macros/patterns/../building-blocks/ast-coercion.html"><code>as_expr!</code> macro</a> and a <code>foo</code> macro that makes use of the first one:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_export]
macro_rules! as_expr { ($e:expr) =&gt; {$e} }

#[macro_export]
macro_rules! foo {
    ($($tts:tt)*) =&gt; {
        as_expr!($($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}</span></code></pre></pre>
<p>This is definitely not the nicest solution we could have for this macro, as it pollutes the global macro namespace as mentioned earlier.
In this specific case <code>as_expr</code> is also a very simple macro that we only used once, so let's "embed" this macro in our <code>foo</code> macro with internal rules!
To do so, we simply prepend a new matcher for our macro, which consists of the matcher used in the <code>as_expr</code> macro, but with a small addition.
We prepend a tokentree that makes it match only when specifically asked to.
In this case we can for example use <code>@as_expr</code>, so our matcher becomes <code>(@as_expr $e:expr) =&gt; {$e};</code>.
With this we get the macro that was defined at the very top of this page:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e};

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}</span></code></pre></pre>
<p>You see how we embedded the <code>as_expr</code> macro in the <code>foo</code> one?
All that changed is that instead of invoking the <code>as_expr</code> macro, we now invoke <code>foo</code> recursively but with a special token tree prepended to the arguments, <code>foo!(@as_expr $($tts)*)</code>.
If you look closely you might even see that this pattern can be combined quite nicely with <a href="decl-macros/patterns/./tt-muncher.html">TT Munchers</a>!</p>
<p>The reason for using <code>@</code> was that, as of Rust 1.2, the <code>@</code> token is <em>not</em> used in prefix position; as such, it cannot conflict with anything.
This reasoning became obsolete later on when in Rust 1.7 macro matchers got future proofed by emitting a warning to prevent certain tokens from being allowed to follow certain fragments<sup class="footnote-reference" id="fr-ambiguity-restrictions-1"><a href="#footnote-ambiguity-restrictions">1</a></sup>, which in Rust 1.12 became a hard-error.
Other symbols or unique prefixes may be used as desired, but use of <code>@</code> has started to become widespread, so using it may aid readers in understanding your macro.</p>
<blockquote>
<p><strong>Note</strong>: in the early days of Rust the <code>@</code> token was previously used in prefix position to denote a garbage-collected pointer, back when the language used sigils to denote pointer types.
Its only <em>current</em> purpose is for binding names to patterns.
For this, however, it is used as an <em>infix</em> operator, and thus does not conflict with its use here.</p>
</blockquote>
<p>Additionally, internal rules will often come <em>before</em> any "bare" rules, to avoid issues with <code>macro_rules!</code> incorrectly attempting to parse an internal invocation as something it cannot possibly be, such as an expression.</p>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>One downside of internal rules is that they can hurt compile times.
Only one macro rule can match any (valid) macro invocation, but the compiler must try to match all rules in order.
If a macro has many rules, there can be many such failures, and the use of internal rules will increase the number of such failures.</p>
<p>Also, the <code>@as_expr</code>-style identifier makes rules longer, slightly increasing
the amount of work the compiler must do when matching.</p>
<p>Therefore, for best performance, avoiding internal rules is best.
Avoiding them often makes complex macros easier to read, too.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-ambiguity-restrictions">
<p><a href="decl-macros/patterns/../minutiae/metavar-and-expansion.html">ambiguity-restrictions</a> <a href="#fr-ambiguity-restrictions-1">â†©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="push-down-accumulation"><a class="header" href="#push-down-accumulation">Push-down Accumulation</a></h1>
<p>The following macro uses <em>push-down accumulation</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! init_array {
    [$e:expr; $n:tt] =&gt; { 
        {   
            let e = $e; 
            accum!([$n, e.clone()] -&gt; [])
        }
    };
}
macro_rules! accum {
    ([3, $e:expr] -&gt; [$($body:tt)*]) =&gt; { accum!([2, $e] -&gt; [$($body)* $e,]) };
    ([2, $e:expr] -&gt; [$($body:tt)*]) =&gt; { accum!([1, $e] -&gt; [$($body)* $e,]) };
    ([1, $e:expr] -&gt; [$($body:tt)*]) =&gt; { accum!([0, $e] -&gt; [$($body)* $e,]) };
    ([0, $_:expr] -&gt; [$($body:tt)*]) =&gt; { [$($body)*] };
}

let strings: [String; 3] = init_array![String::from("hi!"); 3];
<span class="boring">assert_eq!(format!("{:?}", strings), "[\"hi!\", \"hi!\", \"hi!\"]");
</span><span class="boring">}</span></code></pre></pre>
<p>All syntax extensions in Rust <strong>must</strong> result in a complete, supported syntax element (such as an expression, item, <em>etc.</em>).
This means that it is impossible to have a syntax extension expand to a partial construct.</p>
<p>One might hope that the above example could be more directly expressed like so:</p>
<pre><code class="language-rust ignore">macro_rules! init_array {
    [$e:expr; $n:tt] =&gt; {
        {
            let e = $e;
            [accum!($n, e.clone())]
        }
    };
}
macro_rules! accum {
    (3, $e:expr) =&gt; { $e, accum!(2, $e) };
    (2, $e:expr) =&gt; { $e, accum!(1, $e) };
    (1, $e:expr) =&gt; { $e };
}</code></pre>
<p>The expectation is that the expansion of the array literal would proceed as follows:</p>
<pre><code class="language-rust ignore">    [accum!(3, e.clone())]
    [e.clone(), accum!(2, e.clone())]
    [e.clone(), e.clone(), accum!(1, e.clone())]
    [e.clone(), e.clone(), e.clone()]</code></pre>
<p>However, this would require each intermediate step to expand to an incomplete expression.
Even though the intermediate results will never be used <em>outside</em> of a macro context, it is still forbidden.</p>
<p>Push-down, however, allows us to incrementally build up a sequence of tokens without needing to actually have a complete construct at any point prior to completion.
In the example given at the top, the sequence of invocations proceeds as follows:</p>
<pre><code class="language-rust ignore">init_array!(String::from("hi!"); 3)
accum!([3, e.clone()] -&gt; [])
accum!([2, e.clone()] -&gt; [e.clone(),])
accum!([1, e.clone()] -&gt; [e.clone(), e.clone(),])
accum!([0, e.clone()] -&gt; [e.clone(), e.clone(), e.clone(),])
[e.clone(), e.clone(), e.clone(),]</code></pre>
<p>As you can see, each layer adds to the accumulated output until the terminating rule finally emits it as a complete construct.</p>
<p>The only critical part of the above formulation is the use of <code>$($body:tt)*</code> to preserve the output without triggering parsing.
The use of <code>($input) -&gt; ($output)</code> is simply a convention adopted to help clarify the behavior of such macros.</p>
<p>Push-down accumulation is frequently used as part of <a href="decl-macros/patterns/./tt-muncher.html">incremental TT munchers</a>, as it allows arbitrarily complex intermediate results to be constructed.
<a href="decl-macros/patterns/./internal-rules.html">Internal Rules</a> were of use here as well, as they simplify creating such macros.</p>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Push-down accumulation is inherently quadratic.
Consider a push-down accumulation rule that builds up an accumulator of 100 token trees, one token tree per invocation.</p>
<ul>
<li>The initial invocation will match against the empty accumulator.</li>
<li>The first recursive invocation will match against the accumulator of 1 token tree.</li>
<li>The next recursive invocation will match against the accumulator of 2 token trees.</li>
</ul>
<p>And so on, up to 100.
This is a classic quadratic pattern, and long inputs can cause macro expansion to blow out compile times.
Furthermore, TT munchers are also inherently quadratic over their input, so a macro that uses both TT munching <em>and</em> push-down accumulation will be doubly quadratic!</p>
<p>All the <a href="decl-macros/patterns/./tt-muncher.html#performance">performance advice</a> about TT munchers holds for push-down accumulation.
In general, avoid using them too much, and keep them as simple as possible.</p>
<p>Finally, make sure you put the accumulator at the <em>end</em> of rules, rather than the beginning.
That way, if a rule fails, the compiler won't have had to match the (potentially long) accumulator before hitting the part of the rule that fails to match.
This can make a large difference to compile times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repetition-replacement"><a class="header" href="#repetition-replacement">Repetition Replacement</a></h1>
<pre><code class="language-rust ignore">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}</code></pre>
<p>This pattern is where a matched repetition sequence is simply discarded, with the variable being used to instead drive some repeated pattern that is related to the input only in terms of length.</p>
<p>For example, consider constructing a default instance of a tuple with more than 12 elements (the limit as of Rust 1.2).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! tuple_default {
    ($($tup_tys:ty),*) =&gt; {
        (
            $(
                replace_expr!(
                    ($tup_tys)
                    Default::default()
                ),
            )*
        )
    };
}
<span class="boring">
</span><span class="boring">macro_rules! replace_expr {
</span><span class="boring">    ($_t:tt $sub:expr) =&gt; {$sub};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::default(), String::default()));
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: we <em>could</em> have simply used <code>$tup_tys::default()</code>.</p>
</blockquote>
<p>Here, we are not actually <em>using</em> the matched types.
Instead, we throw them away and replace them with a single, repeated expression.
To put it another way, we don't care <em>what</em> the types are, only <em>how many</em> there are.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tt-bundling"><a class="header" href="#tt-bundling">TT Bundling</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! call_a_or_b_on_tail {
    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) =&gt; {
        $a(stringify!($($tail)*))
    };

    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) =&gt; {
        $b(stringify!($($tail)*))
    };

    ($ab:tt, $_skip:tt $($tail:tt)*) =&gt; {
        call_a_or_b_on_tail!($ab, $($tail)*)
    };
}

fn compute_len(s: &amp;str) -&gt; Option&lt;usize&gt; {
    Some(s.len())
}

fn show_tail(s: &amp;str) -&gt; Option&lt;usize&gt; {
    println!("tail: {:?}", s);
    None
}

fn main() {
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            the recursive part that skips over all these
            tokens does not much care whether we will call a
            or call b: only the terminal rules care.
        ),
        None
    );
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            and now, to justify the existence of two paths
            we will also call a: its input should somehow
            be self-referential, so let us make it return
            some ninety-one!
        ),
        Some(87)
    );
}</code></pre></pre>
<p>In particularly complex recursive macros, a large number of arguments may be needed in order to carry identifiers and expressions to successive layers.
However, depending on the implementation there may be many intermediate layers which need to forward these arguments, but do not need to <em>use</em> them.</p>
<p>As such, it can be very useful to bundle all such arguments together into a single TT by placing them in a group.
This allows layers which do not need to use the arguments to simply capture and substitute a single <a href="decl-macros/patterns/../minutiae/fragment-specifiers.html#tt"><code>tt</code></a>, rather than having to exactly capture and substitute the entire argument group.</p>
<p>The example above bundles the <code>$a</code> and <code>$b</code> expressions into a group which can then be forwarded as a single <a href="decl-macros/patterns/../minutiae/fragment-specifiers.html#tt"><code>tt</code></a> by the recursive rule.
This group is then destructured by the terminal rules to access the expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-blocks"><a class="header" href="#building-blocks">Building Blocks</a></h1>
<p>Reusable snippets of <code>macro_rules!</code> macro code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-coercion"><a class="header" href="#ast-coercion">AST Coercion</a></h1>
<p>The Rust parser is not very robust in the face of <code>tt</code> substitutions.
Problems can arise when the parser is expecting a particular grammar construct and <em>instead</em> finds a lump of substituted <code>tt</code> tokens.
Rather than attempt to parse them, it will often just <em>give up</em>. In these cases, it is necessary to employ an AST coercion.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(dead_code)]
</span>macro_rules! as_expr { ($e:expr) =&gt; {$e} }
macro_rules! as_item { ($i:item) =&gt; {$i} }
macro_rules! as_pat  { ($p:pat)  =&gt; {$p} }
macro_rules! as_stmt { ($s:stmt) =&gt; {$s} }
macro_rules! as_ty   { ($t:ty)   =&gt; {$t} }

as_item!{struct Dummy;}

fn main() {
    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42));
}</code></pre></pre>
<p>These coercions are often used with <a href="decl-macros/building-blocks/../patterns/push-down-acc.html">push-down accumulation</a> macros in order to get the parser to treat the final <code>tt</code> sequence as a particular kind of grammar construct.</p>
<p>Note that this specific set of macros is determined by what macros are allowed to expand to, <em>not</em> what they are able to capture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting"><a class="header" href="#counting">Counting</a></h1>
<p>What follows are several techniques for counting in <code>macro_rules!</code> macros:</p>
<blockquote>
<p><strong>Note</strong>: If you are just interested in the most efficient way <a href="decl-macros/building-blocks/./counting.html#bit-twiddling">look here</a></p>
</blockquote>
<h2 id="repetition-with-replacement"><a class="header" href="#repetition-with-replacement">Repetition with replacement</a></h2>
<p>Counting things in a macro is a surprisingly tricky task.
The simplest way is to use replacement with a repetition match.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) =&gt; {0usize $(+ replace_expr!($tts 1usize))*};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This is a fine approach for smallish numbers, but will likely <em>crash the compiler</em> with inputs of around 500 or so tokens.
Consider that the output will look something like this:</p>
<pre><code class="language-rust ignore">0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize</code></pre>
<p>The compiler must parse this into an AST, which will produce what is effectively a perfectly unbalanced binary tree 500+ levels deep.</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>An older approach is to use recursion.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_tts {
    () =&gt; {0usize};
    ($_head:tt $($tail:tt)*) =&gt; {1usize + count_tts!($($tail)*)};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: As of <code>rustc</code> 1.2, the compiler has <em>grievous</em> performance problems when large numbers of integer literals of unknown type must undergo inference.
We are using explicitly <code>usize</code>-typed literals here to avoid that.</p>
<p>If this is not suitable (such as when the type must be substitutable), you can help matters by using <code>as</code> (<em>e.g.</em> <code>0 as $ty</code>, <code>1 as $ty</code>, <em>etc.</em>).</p>
</blockquote>
<p>This <em>works</em>, but will trivially exceed the recursion limit.
Unlike the repetition approach, you can extend the input size by matching multiple tokens at once.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_tts {
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt
     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt
     $($tail:tt)*)
        =&gt; {20usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $($tail:tt)*)
        =&gt; {10usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $($tail:tt)*)
        =&gt; {5usize + count_tts!($($tail)*)};
    ($_a:tt
     $($tail:tt)*)
        =&gt; {1usize + count_tts!($($tail)*)};
    () =&gt; {0usize};
}

fn main() {
    assert_eq!(700, count_tts!(
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        // Repetition breaks somewhere after this
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
    ));
}</code></pre></pre>
<p>This particular formulation will work up to ~1,200 tokens.</p>
<h2 id="slice-length"><a class="header" href="#slice-length">Slice length</a></h2>
<p>A third approach is to help the compiler construct a shallow AST that won't lead to a stack overflow.
This can be done by constructing an array literal and calling the <code>len</code> method.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) =&gt; {&lt;[()]&gt;::len(&amp;[$(replace_expr!($tts ())),*])};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This has been tested to work up to 10,000 tokens, and can probably go much higher.</p>
<h2 id="array-length"><a class="header" href="#array-length">Array length</a></h2>
<p>Another modification of the previous approach is to use const generics stabilized in Rust 1.51.
It's only slightly slower than slice length method on 20,000 tokens and works in const contexts.</p>
<pre><pre class="playground"><code class="language-rust edition2021">const fn count_helper&lt;const N: usize&gt;(_: [(); N]) -&gt; usize { N }

macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; { $sub }
}

macro_rules! count_tts {
    ($($smth:tt)*) =&gt; {
        count_helper([$(replace_expr!($smth ())),*])
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="enum-counting"><a class="header" href="#enum-counting">Enum counting</a></h2>
<p>This approach can be used where you need to count a set of mutually distinct identifiers.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_idents {
    () =&gt; {0};
    ($last_ident:ident, $($idents:ident),* $(,)?) =&gt; {
        {
            #[allow(dead_code, non_camel_case_types)]
            enum Idents { $($idents,)* $last_ident }
            const COUNT: u32 = Idents::$last_ident as u32 + 1;
            COUNT
        }
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    const COUNT: u32 = count_idents!(A, B, C);
</span><span class="boring">    assert_eq!(COUNT, 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This method does have two drawbacks.
As implied above, it can <em>only</em> count valid identifiers (which are also not keywords), and it does not allow those identifiers to repeat.</p>
<h2 id="bit-twiddling"><a class="header" href="#bit-twiddling">Bit twiddling</a></h2>
<p>Another recursive approach using bit operations:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This approach is pretty smart as it effectively halves its input whenever its even and then multiplying the counter by 2 (or in this case shifting 1 bit to the left which is equivalent).
If the input is uneven it simply takes one token tree from the input <code>or</code>s the token tree to the previous counter which is equivalent to adding 1 as the lowest bit has to be a 0 at this point due to the previous shifting.
Rinse and repeat until we hit the base rule <code>() =&gt; 0</code>.</p>
<p>The benefit of this is that the constructed AST expression that makes up the counter value will grow with a complexity of <code>O(log(n))</code> instead of <code>O(n)</code> like the other approaches.
Be aware that you can still hit the recursion limit with this if you try hard enough.
Credits for this method go to Reddit user <a href="https://www.reddit.com/r/rust/comments/d3yag8/the_little_book_of_rust_macros/"><code>YatoRust</code></a>.</p>
<p>Let's go through the procedure by hand once:</p>
<pre><code class="language-rust ignore">count_tts!(0 0 0 0 0 0 0 0 0 0);</code></pre>
<p>This invocation will match the third rule due to the fact that we have an even number of token trees(10).
The matcher names the odd token trees in the sequence <code>$a</code> and the even ones <code>$even</code> but the expansion only makes use of <code>$a</code>, which means it effectively discards all the even elements cutting the input in half.
So the invocation now becomes:</p>
<pre><code class="language-rust ignore">count_tts!(0 0 0 0 0) &lt;&lt; 1;</code></pre>
<p>This invocation will now match the second rule as its input is an uneven amount of token trees.
In this case the first token tree is discarded to make the input even again, then we also do the halving step in this invocation again since we know the input would be even now anyways.
Therefore we can count 1 for the uneven discard and multiply by 2 again since we also halved.</p>
<pre><code class="language-rust ignore">((count_tts!(0 0) &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<pre><code class="language-rust ignore">((count_tts!(0) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<pre><code class="language-rust ignore">((((count_tts!() &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<pre><code class="language-rust ignore">((((0 &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<p>Now to check if we expanded correctly manually we can use a one of the tools we introduced for <a href="decl-macros/building-blocks/../minutiae/debugging.html"><code>debugging</code></a>.
When expanding the macro there we should get:</p>
<pre><code class="language-rust ignore">((((0 &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<p>That's the same so we didn't make any mistakes, great!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abacus-counters"><a class="header" href="#abacus-counters">Abacus Counters</a></h1>
<blockquote>
<p><strong>Provisional</strong>: needs a more compelling example.
Matching nested groups that are <em>not</em> denoted by Rust groups is sufficiently unusual that it may not merit inclusion.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: this section assumes understanding of <a href="decl-macros/building-blocks/abacus-counting.html#push-down-accumulation">push-down accumulation</a> and <a href="decl-macros/building-blocks/abacus-counting.html#incremental-tt-munchers">incremental TT munchers</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! abacus {
    ((- $($moves:tt)*) -&gt; (+ $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((- $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (- $($count)*))
    };
    ((+ $($moves:tt)*) -&gt; (- $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((+ $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (+ $($count)*))
    };

    // Check if the final result is zero.
    (() -&gt; ()) =&gt; { true };
    (() -&gt; ($($count:tt)+)) =&gt; { false };
}

fn main() {
    let equals_zero = abacus!((++-+-+++--++---++----+) -&gt; ());
    assert_eq!(equals_zero, true);
}</code></pre></pre>
<p>This technique can be used in cases where you need to keep track of a varying counter that starts at or near zero, and must support the following operations:</p>
<ul>
<li>Increment by one.</li>
<li>Decrement by one.</li>
<li>Compare to zero (or any other fixed, finite value).</li>
</ul>
<p>A value of <em>n</em> is represented by <em>n</em> instances of a specific token stored in a group.
Modifications are done using recursion and <a href="decl-macros/building-blocks/abacus-counting.html#push-down-accumulation">push-down accumulation</a>.
Assuming the token used is <code>x</code>, the operations above are implemented as follows:</p>
<ul>
<li>Increment by one: match <code>($($count:tt)*)</code>, substitute <code>(x $($count)*)</code>.</li>
<li>Decrement by one: match <code>(x $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>Compare to zero: match <code>()</code>.</li>
<li>Compare to one: match <code>(x)</code>.</li>
<li>Compare to two: match <code>(x x)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>
<p>In this way, operations on the counter are like flicking tokens back and forth like an abacus.<sup class="footnote-reference" id="fr-abacus-1"><a href="#footnote-abacus">1</a></sup></p>
<p>In cases where you want to represent negative values, <em>-n</em> can be represented as <em>n</em> instances of a
<em>different</em> token.
In the example given above, <em>+n</em> is stored as <em>n</em> <code>+</code> tokens, and <em>-m</em> is stored as <em>m</em> <code>-</code> tokens.</p>
<p>In this case, the operations become slightly more complicated; increment and decrement effectively reverse their usual meanings when the counter is negative.
To which given <code>+</code> and <code>-</code> for the positive and negative tokens respectively, the operations change to:</p>
<ul>
<li>Increment by one:
<ul>
<li>match <code>()</code>, substitute <code>(+)</code>.</li>
<li>match <code>(- $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(+ $($count)+)</code>.</li>
</ul>
</li>
<li>Decrement by one:
<ul>
<li>match <code>()</code>, substitute <code>(-)</code>.</li>
<li>match <code>(+ $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(- $($count)+)</code>.</li>
</ul>
</li>
<li>Compare to 0: match <code>()</code>.</li>
<li>Compare to +1: match <code>(+)</code>.</li>
<li>Compare to -1: match <code>(-)</code>.</li>
<li>Compare to +2: match <code>(++)</code>.</li>
<li>Compare to -2: match <code>(--)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>
<p>Note that the example at the top combines some of the rules together (for example, it combines increment on <code>()</code> and <code>($($count:tt)+)</code> into an increment on <code>($($count:tt)*)</code>).</p>
<p>If you want to extract the actual <em>value</em> of the counter, this can be done using a regular <a href="decl-macros/building-blocks/./counting.html">counter macro</a>.
For the example above, the terminal rules can be replaced with the following:</p>
<pre><code class="language-rust ignore">macro_rules! abacus {
    // ...

    // This extracts the counter as an integer expression.
    (() -&gt; ()) =&gt; {0};
    (() -&gt; (- $($count:tt)*)) =&gt; {
        - ( count_tts!($( $count_tts:tt )*) )
    };
    (() -&gt; (+ $($count:tt)*)) =&gt; {
        count_tts!($( $count_tts:tt )*)
    };
}

// One of the many token tree counting macros in the counting chapter
macro_rules! count_tts {
    // ...
}</code></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: strictly speaking, the above formulation of <code>abacus!</code> is needlessly complex.
It can be implemented much more efficiently using repetition, provided you <em>do not</em> need to match against the counter's value in a macro:</p>
<pre><code class="language-ignore">macro_rules! abacus {
    (-) =&gt; {-1};
    (+) =&gt; {1};
    ($( $moves:tt )*) =&gt; {
        0 $(+ abacus!($moves))*
    }
}
</code></pre>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-abacus">
<p>This desperately thin reasoning conceals the <em>real</em> reason for this name: to avoid having
<em>yet another</em> thing with "token" in the name. Talk to your writer about avoiding
<a href="https://en.wikipedia.org/wiki/Semantic_satiation">semantic satiation</a> today!<br />
In fairness, it could <em>also</em> have been called <a href="https://en.wikipedia.org/wiki/Unary_numeral_system">"unary counting"</a>. <a href="#fr-abacus-1">â†©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-rust"><a class="header" href="#parsing-rust">Parsing Rust</a></h1>
<p>Parsing some of Rust's items can be useful in certain situations.
This section will show a few macros that can parse some of Rust's more complex items like structs and functions to a certain extent.
The goal of these macros is not to be able to parse the entire grammar of the items but to parse parts that are in general quite useful without being too complex to parse. This means we ignore things like generics and such.</p>
<p>The main points of interest of these macros are their <code>matchers</code>.
The transcribers are only there for example purposes and are usually not that impressive.</p>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! function_item_matcher {
    (

        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)? )
    //                          ^~~~~~~~~~~~~~~~argument list~~~~~~~~~~~~~~~^
            $( -&gt; $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -&gt; $ret_ty )? { $($tt)* }
    }
}

<span class="boring">function_item_matcher!(
</span><span class="boring">    #[inline]
</span><span class="boring">    #[cold]
</span><span class="boring">    pub fn foo(bar: i32, baz: i32, ) -&gt; String {
</span><span class="boring">        format!("{} {}", bar, baz)
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo(13, 37), "13 37");
</span><span class="boring">}</span></code></pre></pre>
<p>A simple function matcher that ignores qualifiers like <code>unsafe</code>, <code>async</code>, ... as well as generics and where clauses.
If parsing those is required it is likely that you are better off using a proc-macro instead.</p>
<p>This lets you for example, inspect the function signature, generate some extra things from it and then re-emit the entire function again.
Kind of like a <code>Derive</code> proc-macro but weaker and for functions.</p>
<blockquote>
<p>Ideally we would like to use a pattern fragment specifier instead of an ident for the arguments but this is currently not allowed.
Fortunately people don't use non-identifier patterns in function signatures that often so this is okay(a shame, really).</p>
</blockquote>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<p>The macro for parsing basic functions is nice and all, but sometimes we would like to also parse methods, functions that refer to their object via some form of <code>self</code> usage. This makes things a bit trickier:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! method_item_matcher {
    // self
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
    //                          ^~~~~~~~~~~~~~~~~~~~~argument list~~~~~~~~~~~~~~~~~~~~~~^
            $( -&gt; $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    };

    // mut self
    (
        $( #[$meta:meta] )*
        $vis:vis fn $name:ident ( mut $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
            $( -&gt; $ret_ty:ty )?
            { $($tt:tt)* }
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( mut $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    };

    // &amp;self
    (
        $( #[$meta:meta] )*
        $vis:vis fn $name:ident ( &amp; $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
            $( -&gt; $ret_ty:ty )?
            { $($tt:tt)* }
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( &amp; $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    };

    // &amp;mut self
    (
        $( #[$meta:meta] )*
        $vis:vis fn $name:ident ( &amp;mut $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
            $( -&gt; $ret_ty:ty )?
            { $($tt:tt)* }
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( &amp;mut $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    }
}

<span class="boring">struct T(i32);
</span><span class="boring">impl T {
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        #[inline]
</span><span class="boring">        pub fn s(self, x: i32) -&gt; String { format!("{}", x) }
</span><span class="boring">    );
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        pub fn ms(mut self, x: i32,) -&gt; String { format!("{}", x) }
</span><span class="boring">    );
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        pub fn rs(&amp;self, x: i32, y: i32) -&gt; String { format!("{}", self.0 + x + y) }
</span><span class="boring">    );
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        pub fn rms(&amp;mut self) -&gt; String { self.0.to_string() }
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!({ let t = T(11); t.s(11) }, "11");
</span><span class="boring">    assert_eq!({ let t = T(22); t.ms(22) }, "22");
</span><span class="boring">    assert_eq!({ let t = T(30); t.rs(1, 2) }, "33");
</span><span class="boring">    assert_eq!({ let mut t = T(44); t.rms() }, "44");
</span><span class="boring">}</span></code></pre></pre>
<p>The four rules are identical except for the <code>self</code> receiver on both sides of the rule, which is <code>self</code>, <code>mut self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>.
You might not need all four rules.</p>
<p><code>$self:ident</code> must be used in the matcher instead of a bare <code>self</code>.
Without that, uses of <code>self</code> in the body will cause compile errors, because a macro invocation can only access identifiers it receives from parameters.</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! struct_item_matcher {
    // Unit-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident;
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name;
    };

    // Tuple-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident (
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~~^
                $field_vis:vis $field_ty:ty
    //          ^~~~~~a single field~~~~~~^
            ),*
        $(,)? );
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name (
            $(
                $( #[$field_meta] )*
                $field_vis $field_ty
            ),*
        );
    };

    // Named-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident {
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~!^
                $field_vis:vis $field_name:ident : $field_ty:ty
    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
            ),*
        $(,)? }
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name {
            $(
                $( #[$field_meta] )*
                $field_vis $field_name : $field_ty
            ),*
        }
    }
}

<span class="boring">struct_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) struct Foo {
</span><span class="boring">       pub bar: i32,
</span><span class="boring">       baz: &amp;'static str,
</span><span class="boring">       qux: f32
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) struct Bar;
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">    #[derive(Clone)]
</span><span class="boring">    pub(crate) struct Baz (i32, pub f32, String);
</span><span class="boring">);
</span><span class="boring">fn main() {
</span><span class="boring">    let _: Foo = Foo { bar: 42, baz: "macros can be nice", qux: 3.14, };
</span><span class="boring">    let _: Bar = Bar;
</span><span class="boring">    let _: Baz = Baz(2, 0.1234, String::new());
</span><span class="boring">}</span></code></pre></pre>
<h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Parsing enums is a bit more complex than structs so we will finally make use of some of the <a href="decl-macros/building-blocks/../patterns.html">patterns</a> we have discussed, <a href="decl-macros/building-blocks/../patterns/tt-muncher.html">Incremental TT Muncher</a> and <a href="decl-macros/building-blocks/../patterns/internal-rules.html">Internal Rules</a>.
Instead of just building the parsed enum again we will merely visit all the tokens of the enum, as rebuilding the enum would require us to collect all the parsed tokens temporarily again via a <a href="decl-macros/building-blocks/../patterns/push-down-acc.html">Push Down Accumulator</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! enum_item_matcher {
    // tuple variant
    (@variant $variant:ident (
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~~^
            $field_vis:vis $field_ty:ty
    //      ^~~~~~a single field~~~~~~^
        ),* $(,)?
    //âˆ¨~~rest of input~~âˆ¨
    ) $(, $($tt:tt)* )? ) =&gt; {

        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // named variant
    (@variant $variant:ident {
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~!^
            $field_vis:vis $field_name:ident : $field_ty:ty
    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
        ),* $(,)?
    //âˆ¨~~rest of input~~âˆ¨
    } $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // unit variant
    (@variant $variant:ident $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // trailing comma
    (@variant ,) =&gt; {};
    // base case
    (@variant) =&gt; {};
    // entry point
    (
        $( #[$meta:meta] )*
        $vis:vis enum $name:ident {
            $($tt:tt)*
        }
    ) =&gt; {
        enum_item_matcher!(@variant $($tt)*)
    };
}

<span class="boring">enum_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) enum Foo {
</span><span class="boring">        Bar,
</span><span class="boring">        Baz,
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) enum Bar {
</span><span class="boring">        Foo(i32, f32),
</span><span class="boring">        Bar,
</span><span class="boring">        Baz(),
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">    #[derive(Clone)]
</span><span class="boring">    pub(crate) enum Baz {}
</span><span class="boring">);
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros-20"><a class="header" href="#macros-20">Macros 2.0</a></h1>
<blockquote>
<p><em>RFC</em>: <a href="https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md">rfcs#1584</a><br />
<em>Tracking Issue</em>: <a href="https://github.com/rust-lang/rust/issues/39412">rust#39412</a><br />
<em>Feature</em>: <code>#![feature(decl_macro)]</code></p>
</blockquote>
<p>While not yet stable(or rather far from being finished), there is proposal for a new declarative macro system that is supposed to replace <code>macro_rules!</code> dubbed declarative macros 2.0, <code>macro</code>, <code>decl_macro</code> or confusingly also <code>macros-by-example</code>.</p>
<p>This chapter is only meant to quickly glance over the current state, showing how to use this macro system and where it differs.
Nothing described here is final or complete, and may be subject to change.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>We'll do a comparison between the <code>macro</code> and <code>macro_rules</code> syntax for two macros we have implemented in previous chapters:</p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(decl_macro)]

macro_rules! replace_expr_ {
    ($_t:tt $sub:expr) =&gt; { $sub }
}
macro replace_expr($_t:tt $sub:expr) {
    $sub
}

macro_rules! count_tts_ {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}
macro count_tts {
    () =&gt; { 0 },
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 },
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 },
}</code></pre>
<p>As can be seen, they look very similar, with just a few differences as well as that <code>macro</code>s have two different forms.</p>
<p>Let's inspect the <code>count_tts</code> macro first, as that one looks more like what we are used to.
As can be seen, it practically looks identical to the <code>macro_rules</code> version with two exceptions, it uses the <code>macro</code> keyword and the rule separator is a <code>,</code> instead of a <code>;</code>.</p>
<p>There is a second form to this though, which is a shorthand for macros that only have one rule.
Taking a look at <code>replace_expr</code> we can see that in this case we can write the definition in a way that more resembles an ordinary function.
We can write the matcher directly after the name followed by the transcriber, dropping a pair of braces and the <code>=&gt;</code> token.</p>
<p>Syntax for invoking <code>macro</code>s is the same as for <code>macro_rules</code> and function-like procedural macros, the name followed by a <code>!</code> followed by the macro input token tree.</p>
<h2 id="macro-are-proper-items"><a class="header" href="#macro-are-proper-items"><code>macro</code> are proper items</a></h2>
<p>Unlike with <code>macro_rules</code> macros, which are textually scoped and require <code>#[macro_export]</code>(and potentially a re-export) to be treated as an item, <code>macro</code> macros behave like proper rust items by default.</p>
<p>As such, you can properly qualify them with visibility specifiers like <code>pub</code>, <code>pub(crate)</code>, <code>pub(in path)</code> and the like.</p>
<h2 id="hygiene-2"><a class="header" href="#hygiene-2">Hygiene</a></h2>
<p>Hygiene is by far the biggest difference between the two declarative macro systems.
Unlike <code>macro_rules</code> which have <a href="decl-macros/./minutiae/hygiene.html">mixed site hygiene</a>, <code>macro</code> have definition site hygiene, meaning they do not leak identifiers outside of their invocation.</p>
<p>As such the following compiles with a <code>macro_rules</code> macro, but fails with a <code>macro</code> definition:</p>
<pre><code class="language-rust ignore"><span class="boring">// This code block marked `ignore` because mdbook can't handle `#![feature(...)]`.
</span>#![feature(decl_macro)]
// try uncommenting the following line, and commenting out the line right after

macro_rules! foo {
// macro foo {
    ($name: ident) =&gt; {
        pub struct $name;

        impl $name {
            pub fn new() -&gt; $name {
                $name
            }
        }
    }
}

foo!(Foo);

fn main() {
    // this fails with a `macro`, but succeeds with a `macro_rules`
    let foo = Foo::new();
}</code></pre>
<p>There may be plans to allow escaping hygiene for identifiers(hygiene bending) in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h1>
<blockquote>
<p>Note: This section is still very incomplete!</p>
</blockquote>
<p>This chapter will introduce Rust's second syntax extension type, <em>procedural macros</em>.</p>
<p>As with the <a href="./decl-macros.html">declarative macros</a> chapter, this one is also split into a <a href="./proc-macros/methodical.html">methodical</a> and a (WIP) practical subchapter with the former being a more formal introduction and the latter being a more practical oriented one.</p>
<p>A lot of the basic information covered has been sourced from the <a href="https://doc.rust-lang.org/nightly/reference/introduction.html">rust reference</a>, as most knowledge about procedural macros is currently located there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-methodical-introduction"><a class="header" href="#a-methodical-introduction">A Methodical Introduction</a></h1>
<p>This chapter will introduce Rust's procedural macro system by explaining the system as a whole.</p>
<p>Unlike a <a href="proc-macros/../decl-macros.html">declarative macro</a>, a procedural macro takes the form of a Rust function taking in a token stream(or two) and outputting a token stream.</p>
<p>A proc-macro is at its core just a function exported from a crate with the <code>proc-macro</code> <a href="https://doc.rust-lang.org/reference/linkage.html">crate type</a>, so when writing multiple proc macros you can have them all live in one crate.</p>
<blockquote>
<p><strong>Note</strong>: When using Cargo, to define a <code>proc-macro</code> crate you define and set the <code>lib.proc-macro</code> key in the <code>Cargo.toml</code> to true.</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<p>A <code>proc-macro</code> type crate implicitly links to the compiler-provided <a href="https://doc.rust-lang.org/proc_macro/index.html">proc_macro</a> crate, which contains all the things you need to get going with developing procedural macros.
The two most important types exposed by the crate are the <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>, which are the proc-macro variant of the already familiar token trees as well as the <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html"><code>Span</code></a>, which describes a part of source code used primarily for error reporting and hygiene. See the <a href="proc-macros/./hygiene.html">Hygiene and Spans</a> chapter for more information.</p>
<p>As proc-macros therefore are functions living in a crate, they can be addressed as all the other items in a Rust project.
All that is required is to add the crate to the dependency graph of a project and bring the desired item into scope.</p>
<blockquote>
<p><strong>Note</strong>: Procedural macros invocations still run at the same stage in the compiler expansion-wise as declarative macros, just that they are standalone Rust programs that the compiler compiles, runs, and finally either replaces or appends to.</p>
</blockquote>
<h2 id="types-of-procedural-macros"><a class="header" href="#types-of-procedural-macros">Types of procedural macros</a></h2>
<p>With procedural macros, there actually exists 3 different kinds with each having slightly different properties.</p>
<ul>
<li><em>function-like</em> proc-macros which are used to implement <code>$name ! $arg</code> invocable macros</li>
<li><em>attribute</em> proc-macros which are used to implement <code>#[$arg]</code> attributes</li>
<li><em>derive</em> proc-macros which are used to implement a derive, an <em>input</em> to a <code>#[derive(â€¦)]</code> attribute</li>
</ul>
<p>At their core, all 3 work almost the same with a few differences in their inputs and output reflected by their function definition.
As mentioned all a procedural macro really is, is a function that maps a token stream so let's take a quick look at each basic definition and their differences.</p>
<h3 id="function-like"><a class="header" href="#function-like"><em>function-like</em></a></h3>
<pre><code class="language-rs">#[proc_macro]
pub fn my_proc_macro(input: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<h3 id="attribute"><a class="header" href="#attribute"><em>attribute</em></a></h3>
<pre><code class="language-rs">#[proc_macro_attribute]
pub fn my_attribute(input: TokenStream, annotated_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<h3 id="derive"><a class="header" href="#derive"><em>derive</em></a></h3>
<pre><code class="language-rs">#[proc_macro_derive(MyDerive)]
pub fn my_derive(annotated_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<p>As shown, the basic structure is the same for each, a public function marked with an attribute defining its procedural macro type returning a <code>TokenStream</code>.
Note how the return type is a <code>TokenStream</code> and not a result or something else that gives the notion of being fallible.
This does not mean that proc-macros cannot fail though, in fact they have two ways of reporting errors, the first one being to panic and the second to emit a <a href="https://doc.rust-lang.org/std/macro.compile_error.html"><code>compile_error!</code></a> invocation.
If a proc-macro panics the compiler will catch it and emit the payload as an error coming from the macro invocation.</p>
<blockquote>
<p><strong>Beware</strong>: The compiler will happily hang on endless loops spun up inside proc-macros causing the compilation of crates using the proc-macro to hang as well.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-like-1"><a class="header" href="#function-like-1">Function-like</a></h1>
<p>Function-like procedural macros are invoked like declarative macros that is <code>makro!(â€¦)</code>.</p>
<p>This type of macro is the simplest of the three though.
It is also the only one which you can't differentiate from declarative macros when solely looking at the invocation.</p>
<p>A simple skeleton of a function-like procedural macro looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro]
pub fn tlborm_fn_macro(input: TokenStream) -&gt; TokenStream {
    input
}
</code></pre>
<p>As one can see this is in fact just a mapping from one <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> to another where the <code>input</code> will be the tokens inside of the invocation delimiters, e.g. for an example invocation <code>foo!(bar)</code> the input token stream would consist of the <code>bar</code> token.
The returned token stream will <strong>replace</strong> the macro invocation.</p>
<p>For this macro type the same placement and expansion rules apply as for declarative macros, that is the macro must output a correct token stream for the invocation location.
Unlike with declarative macros though, function-like procedural macros do not have certain restrictions imposed on their inputs though.
That is the restrictions for what may follow fragment specifiers listed in the <a href="proc-macros/methodical/../../decl-macros/minutiae/metavar-and-expansion.html">Metavariables and Expansion Redux</a> chapter listed is not applicable here, as the procedural macros work on the tokens directly instead of matching them against fragment specifiers or similar.</p>
<p>With that said it is apparent that the procedural counter part to these macros is more powerful as they can arbitrarily modify their input, and produce any output desired as long as its within the bounds of the language syntax.</p>
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::tlborm_attribute;

fn foo() {
    tlborm_attribute!(be quick; time is mana);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-1"><a class="header" href="#attribute-1">Attribute</a></h1>
<p>Attribute procedural macros define new <em>outer</em> attributes which can be attached to items.
This type can be invoked with the <code>#[attr]</code> or <code>#[attr(â€¦)]</code> syntax where <code>â€¦</code> is an arbitrary token tree.</p>
<p>A simple skeleton of an attribute procedural macro looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -&gt; TokenStream {
    annotated_item
}
</code></pre>
<p>Of note here is that unlike the other two procedural macro kinds, this one has two input parameters instead of one.</p>
<ul>
<li>The first parameter is the delimited token tree following the attribute's name, excluding the delimiters around it.
It is empty if the attribute is written bare, that is just a name without a <code>(TokenTree)</code> following it, e.g. <code>#[attr]</code>.</li>
<li>The second token stream is the item the attribute is attached to <em>without</em> the attribute this proc macro defines.
As this is an <a href="https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes"><code>active</code></a> attribute, the attribute will be stripped from the item before it is being passed to the proc macro.</li>
</ul>
<p>The returned token stream will <strong>replace</strong> the annotated item fully.
Note that the replacement does not have to be a single item, it can be 0 or more.</p>
<!-- CONFIRM: Is this true? Can it emit an empty token stream? -->
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::tlborm_attribute;

#[tlborm_attribute]
fn foo() {}

#[tlborm_attribute(attributes are pretty handsome)]
fn bar() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-1"><a class="header" href="#derive-1">Derive</a></h1>
<p>Derive procedural macros define new inputs for the <a href="https://doc.rust-lang.org/reference/attributes/derive.html"><code>derive</code></a> attribute.
This type can be invoked by feeding it to a derive attribute's input, e.g. <code>#[derive(TlbormDerive)]</code>.</p>
<p>A simple skeleton of a derive procedural macro looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro_derive(TlbormDerive)]
pub fn tlborm_derive(item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<p>The <code>proc_macro_derive</code> is a bit more special in that it requires an extra identifier, this identifier will become the actual name of the derive proc macro.
The input token stream is the item the derive attribute is attached to, that is, it will always be an <code>enum</code>, <code>struct</code> or <code>union</code> as these are the only items a derive attribute can annotate.
The returned token stream will be <strong>appended</strong> to the containing block or module of the annotated item with the requirement that the token stream consists of a set of valid items.</p>
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::TlbormDerive;

#[derive(TlbormDerive)]
struct Foo;
</code></pre>
<h3 id="helper-attributes"><a class="header" href="#helper-attributes">Helper Attributes</a></h3>
<p>Derive proc macros are a bit more special in that they can add additional attributes visible only in the scope of the item definition.
These attributes are called <em>derive macro helper attributes</em> and are <a href="https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes">inert</a>.
Their purpose is to give derive proc macros additional customizability on a per field or variant basis, that is these attributes can be used to annotate fields or enum variants while having no effect on their own.
As they are <code>inert</code> they will not be stripped and are visible to all macros.</p>
<p>They can be defined by adding an <code>attributes(helper0, helper1, ..)</code> argument to the <code>proc_macro_derive</code> attribute containing a comma separated list of identifiers which are the names of the helper attributes.</p>
<p>Thus a simple skeleton of a derive procedural macro with helper attributes looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro_derive(TlbormDerive, attributes(tlborm_helper))]
pub fn tlborm_derive(item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<p>That is all there is to helper attributes, to consume them in the proc macro the implementation will then have to check the attributes of fields and variants to see whether they are attributed with the corresponding helper.
It is an error to use a helper attribute if none of the used derive macros of the given item declare it as such, as the compiler will then instead try to resolve it as a normal attribute.</p>
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::TlbormDerive;

#[derive(TlbormDerive)]
struct Foo {
    #[tlborm_helper]
    field: u32
}

#[derive(TlbormDerive)]
enum Bar {
    #[tlborm_helper]
    Variant { #[tlborm_helper] field: u32 }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-party-crates"><a class="header" href="#third-party-crates">Third-Party Crates</a></h1>
<blockquote>
<p><strong>Note</strong>: Crates beyond the automatically linked <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate are not required to write procedural macros.
The crates listed here merely make writing them simpler and more concise, while potentially adding to the compilation time of the procedural macro due to added dependencies.</p>
</blockquote>
<p>As procedural macros live in a crate they can naturally depend on (<a href="https://crates.io/">crates.io</a>) crates.
turns out the crate ecosystem has some really helpful crates tailored towards procedural macros that this chapter will quickly go over, most of which will be used in the following chapters to implement the example macros.
As these are merely quick introductions it is advised to look at each crate's documentation for more in-depth information if required.</p>
<h2 id="proc-macro2"><a class="header" href="#proc-macro2"><a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a></a></h2>
<p><a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a>, the successor of the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate! Or so you might think but that is of course not correct, the name might be a bit misleading.
This crate is actually just a wrapper around the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate serving two specific purposes, taken from the documentation:</p>
<ul>
<li>Bring proc-macro-like functionality to other contexts like build.rs and main.rs.</li>
<li>Make procedural macros unit testable.</li>
</ul>
<p>As the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate is exclusive to <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> type crates, making them unit testable or accessing them from non-proc macro code is next to impossible.
With that in mind the <a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a> crate mimics the original <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate's api, acting as a wrapper in proc-macro crates and standing on its own in non-proc-macro crates.
Hence it is advised to build libraries targeting proc-macro code to be built against <a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a> instead as that will enable those libraries to be unit testable, which is also the reason why the following listed crates take and emit <a href="https://docs.rs/proc-macro2/1.0.27/proc_macro2/struct.TokenStream.html"><code>proc-macro2::TokenStream</code></a>s instead.
When a <code>proc_macro</code> token stream is required, one can simply <code>.into()</code> the <code>proc-macro2</code> token stream to get the <code>proc_macro</code> version and vice-versa.</p>
<p>Procedural macros using the <code>proc-macro2</code> crate will usually import the <code>proc-macro2::TokenStream</code> in an aliased form like <code>use proc-macro2::TokenStream as TokenStream2</code>.</p>
<h2 id="quote"><a class="header" href="#quote"><a href="https://docs.rs/quote/*/quote/"><code>quote</code></a></a></h2>
<p>The <a href="https://docs.rs/quote/*/quote/"><code>quote</code></a> crate mainly exposes just one macro, the <a href="https://docs.rs/quote/1/quote/macro.quote.html"><code>quote!</code></a> macro.</p>
<p>This little macro allows you to easily create token streams by writing the actual source out as syntax while also giving you the power of interpolating tokens right into the written syntax.
<a href="https://docs.rs/quote/1/quote/macro.quote.html#interpolation">Interpolation</a> can be done by using the <code>#local</code> syntax where local refers to a local in the current scope.
Likewise <code>#( #local )*</code> can be used to interpolate over an iterator of types that implement <a href="https://docs.rs/quote/1/quote/trait.ToTokens.html"><code>ToTokens</code></a>, this works similar to declarative <code>macro_rules!</code> repetitions in that they allow a separator as well as extra tokens inside the repetition.</p>
<pre><code class="language-rs">let name = /* some identifier */;
let exprs = /* an iterator over expressions tokenstreams */;
let expanded = quote! {
    impl SomeTrait for #name { // #name interpolates the name local from above
        fn some_function(&amp;self) -&gt; usize {
            #( #exprs )* // #name interpolates exprs by iterating the iterator
        }
    }
};
</code></pre>
<p>This a very useful tool when preparing macro output avoiding the need of creating a token stream by inserting tokens one by one.</p>
<blockquote>
<p><strong>Note</strong>: As stated earlier, this crate makes use of <code>proc_macro2</code> and thus the <code>quote!</code> macro returns a <code>proc-macro2::TokenStream</code>.</p>
</blockquote>
<h2 id="syn"><a class="header" href="#syn"><a href="https://docs.rs/syn/*/syn/"><code>syn</code></a></a></h2>
<p>The <a href="https://docs.rs/syn/*/syn/"><code>syn</code></a> crate is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.
It is a very powerful library that makes parsing proc-macro input quite a bit easier, as the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate itself does not expose any kind of parsing capabilities, merely the tokens.
As the library can be a heavy compilation dependency, it makes heavy use of feature gates to allow users to cut it as small as required.</p>
<p>So what does it offer? A bunch of things.</p>
<p>First of all it has definitions and parsing for all standard Rust syntax nodes(when the <code>full</code> feature is enabled), as well as a <a href="https://docs.rs/syn/1/syn/struct.DeriveInput.html"><code>DeriveInput</code></a> type which encapsulates all the information a derive macro gets passed as an input stream as a structured input(requires the <code>derive</code> feature, enabled by default). These can be used right out of the box with the <a href="https://docs.rs/syn/1/syn/macro.parse_macro_input.html"><code>parse_macro_input!</code></a> macro(requires the <code>parsing</code> and <code>proc-macro</code> features, enabled by default) to parse token streams into these types.</p>
<p>If Rust syntax doesn't cut it, and instead one wishes to parse custom non-Rust syntax the crate also offers a generic <a href="https://docs.rs/syn/1/syn/parse/index.html">parsing API</a>, mainly in the form of the <a href="https://docs.rs/syn/1/syn/parse/trait.Parse.html"><code>Parse</code></a> trait(requires the <code>parsing</code> feature, enabled by default).</p>
<p>Aside from this the types exposed by the library keep location information and spans which allows procedural macros to emit detailed error messages pointing at the macro input at the points of interest.</p>
<p>As this is again a library for procedural macros, it makes use of the <code>proc_macro2</code> token streams and spans and as such, conversions may be required.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hygiene-and-spans"><a class="header" href="#hygiene-and-spans">Hygiene and Spans</a></h1>
<p>This chapter talks about procedural macro <a href="proc-macros/../syntax-extensions/hygiene.html">hygiene</a> and the type that encodes it, <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html"><code>Span</code></a>.</p>
<p>Every token in a <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> has an associated <code>Span</code> holding some additional info.
A span, as its documentation states, is <code>A region of source code, along with macro expansion information</code>.
It points into a region of the original source code(important for displaying diagnostics at the correct places) as well as holding the kind of <em>hygiene</em> for this location.
The hygiene is relevant mainly for identifiers, as it allows or forbids the identifier from referencing things or being referenced by things defined outside of the invocation.</p>
<p>There are 3 kinds of hygiene(which can be seen by the constructors of the <code>Span</code> type):</p>
<ul>
<li><a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.def_site"><code>definition site</code></a>(<em><strong>unstable</strong></em>): A span that resolves at the macro definition site. Identifiers with this span will not be able to reference things defined outside or be referenced by things outside of the invocation. This is what one would call "hygienic".</li>
<li><a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.mixed_site"><code>mixed site</code></a>: A span that has the same hygiene as <code>macro_rules</code> declarative macros, that is it may resolve to definition site or call site depending on the type of identifier. See <a href="proc-macros/../decl-macros/minutiae/hygiene.html">here</a> for more information.</li>
<li><a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.call_site"><code>call site</code></a>: A span that resolves to the invocation site. Identifiers in this case will behave as if written directly at the call site, that is they freely resolve to things defined outside of the invocation and can be referenced from the outside as well. This is what one would call "unhygienic".</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>A place for obscure words and their descriptions.
If you feel like there is an important word missing here, please open an <a href="https://github.com/Veykril/tlborm/issues/new">issue</a> or a pull request.</p>
<h2 id="function-like-macro"><a class="header" href="#function-like-macro">Function-like macro</a></h2>
<p>A function like macro describes a syntax extension that can be invoked via the form <code>identifier!(...)</code>.
It is called this way due to its resemblance of a function call.</p>
<h2 id="syntax-extension"><a class="header" href="#syntax-extension">Syntax Extension</a></h2>
<p>The mechanism Rust's <code>macro_rules!</code> and procedural macros are built on.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
